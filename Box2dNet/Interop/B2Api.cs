// Generated by Box2dNetGen for Box2D v3 on 22/06/2025 13:52:12

using System.Runtime.InteropServices;
using System.Numerics;

// ReSharper disable InconsistentNaming

namespace Box2dNet.Interop
{

public enum b2TOIState
{

  b2_toiStateUnknown,

  b2_toiStateFailed,

  b2_toiStateOverlapped,

  b2_toiStateHit,
}

public enum b2BodyType
{

  /// <summary>
  /// zero mass, zero velocity, may be manually moved
  /// </summary>
  b2_staticBody = 0,

  /// <summary>
  /// zero mass, velocity set by user, moved by solver
  /// </summary>
  b2_kinematicBody = 1,

  /// <summary>
  /// positive mass, velocity determined by forces, moved by solver
  /// </summary>
  b2_dynamicBody = 2,

  /// <summary>
  /// number of body types
  /// </summary>
  b2_bodyTypeCount,
}

public enum b2ShapeType
{

  /// <summary>
  /// A circle with an offset
  /// </summary>
  b2_circleShape,

  /// <summary>
  /// A capsule is an extruded circle
  /// </summary>
  b2_capsuleShape,

  /// <summary>
  /// A line segment
  /// </summary>
  b2_segmentShape,

  /// <summary>
  /// A convex polygon
  /// </summary>
  b2_polygonShape,

  /// <summary>
  /// A line segment owned by a chain shape
  /// </summary>
  b2_chainSegmentShape,
}

public enum b2JointType
{

  b2_distanceJoint,

  b2_filterJoint,

  b2_motorJoint,

  b2_mouseJoint,

  b2_prismaticJoint,

  b2_revoluteJoint,

  b2_weldJoint,

  b2_wheelJoint,
}

public enum b2HexColor
{

  b2_colorAliceBlue = 0xF0F8FF,

  b2_colorAntiqueWhite = 0xFAEBD7,

  b2_colorAqua = 0x00FFFF,

  b2_colorAquamarine = 0x7FFFD4,

  b2_colorAzure = 0xF0FFFF,

  b2_colorBeige = 0xF5F5DC,

  b2_colorBisque = 0xFFE4C4,

  b2_colorBlack = 0x000000,

  b2_colorBlanchedAlmond = 0xFFEBCD,

  b2_colorBlue = 0x0000FF,

  b2_colorBlueViolet = 0x8A2BE2,

  b2_colorBrown = 0xA52A2A,

  b2_colorBurlywood = 0xDEB887,

  b2_colorCadetBlue = 0x5F9EA0,

  b2_colorChartreuse = 0x7FFF00,

  b2_colorChocolate = 0xD2691E,

  b2_colorCoral = 0xFF7F50,

  b2_colorCornflowerBlue = 0x6495ED,

  b2_colorCornsilk = 0xFFF8DC,

  b2_colorCrimson = 0xDC143C,

  b2_colorCyan = 0x00FFFF,

  b2_colorDarkBlue = 0x00008B,

  b2_colorDarkCyan = 0x008B8B,

  b2_colorDarkGoldenRod = 0xB8860B,

  b2_colorDarkGray = 0xA9A9A9,

  b2_colorDarkGreen = 0x006400,

  b2_colorDarkKhaki = 0xBDB76B,

  b2_colorDarkMagenta = 0x8B008B,

  b2_colorDarkOliveGreen = 0x556B2F,

  b2_colorDarkOrange = 0xFF8C00,

  b2_colorDarkOrchid = 0x9932CC,

  b2_colorDarkRed = 0x8B0000,

  b2_colorDarkSalmon = 0xE9967A,

  b2_colorDarkSeaGreen = 0x8FBC8F,

  b2_colorDarkSlateBlue = 0x483D8B,

  b2_colorDarkSlateGray = 0x2F4F4F,

  b2_colorDarkTurquoise = 0x00CED1,

  b2_colorDarkViolet = 0x9400D3,

  b2_colorDeepPink = 0xFF1493,

  b2_colorDeepSkyBlue = 0x00BFFF,

  b2_colorDimGray = 0x696969,

  b2_colorDodgerBlue = 0x1E90FF,

  b2_colorFireBrick = 0xB22222,

  b2_colorFloralWhite = 0xFFFAF0,

  b2_colorForestGreen = 0x228B22,

  b2_colorFuchsia = 0xFF00FF,

  b2_colorGainsboro = 0xDCDCDC,

  b2_colorGhostWhite = 0xF8F8FF,

  b2_colorGold = 0xFFD700,

  b2_colorGoldenRod = 0xDAA520,

  b2_colorGray = 0x808080,

  b2_colorGreen = 0x008000,

  b2_colorGreenYellow = 0xADFF2F,

  b2_colorHoneyDew = 0xF0FFF0,

  b2_colorHotPink = 0xFF69B4,

  b2_colorIndianRed = 0xCD5C5C,

  b2_colorIndigo = 0x4B0082,

  b2_colorIvory = 0xFFFFF0,

  b2_colorKhaki = 0xF0E68C,

  b2_colorLavender = 0xE6E6FA,

  b2_colorLavenderBlush = 0xFFF0F5,

  b2_colorLawnGreen = 0x7CFC00,

  b2_colorLemonChiffon = 0xFFFACD,

  b2_colorLightBlue = 0xADD8E6,

  b2_colorLightCoral = 0xF08080,

  b2_colorLightCyan = 0xE0FFFF,

  b2_colorLightGoldenRodYellow = 0xFAFAD2,

  b2_colorLightGray = 0xD3D3D3,

  b2_colorLightGreen = 0x90EE90,

  b2_colorLightPink = 0xFFB6C1,

  b2_colorLightSalmon = 0xFFA07A,

  b2_colorLightSeaGreen = 0x20B2AA,

  b2_colorLightSkyBlue = 0x87CEFA,

  b2_colorLightSlateGray = 0x778899,

  b2_colorLightSteelBlue = 0xB0C4DE,

  b2_colorLightYellow = 0xFFFFE0,

  b2_colorLime = 0x00FF00,

  b2_colorLimeGreen = 0x32CD32,

  b2_colorLinen = 0xFAF0E6,

  b2_colorMagenta = 0xFF00FF,

  b2_colorMaroon = 0x800000,

  b2_colorMediumAquaMarine = 0x66CDAA,

  b2_colorMediumBlue = 0x0000CD,

  b2_colorMediumOrchid = 0xBA55D3,

  b2_colorMediumPurple = 0x9370DB,

  b2_colorMediumSeaGreen = 0x3CB371,

  b2_colorMediumSlateBlue = 0x7B68EE,

  b2_colorMediumSpringGreen = 0x00FA9A,

  b2_colorMediumTurquoise = 0x48D1CC,

  b2_colorMediumVioletRed = 0xC71585,

  b2_colorMidnightBlue = 0x191970,

  b2_colorMintCream = 0xF5FFFA,

  b2_colorMistyRose = 0xFFE4E1,

  b2_colorMoccasin = 0xFFE4B5,

  b2_colorNavajoWhite = 0xFFDEAD,

  b2_colorNavy = 0x000080,

  b2_colorOldLace = 0xFDF5E6,

  b2_colorOlive = 0x808000,

  b2_colorOliveDrab = 0x6B8E23,

  b2_colorOrange = 0xFFA500,

  b2_colorOrangeRed = 0xFF4500,

  b2_colorOrchid = 0xDA70D6,

  b2_colorPaleGoldenRod = 0xEEE8AA,

  b2_colorPaleGreen = 0x98FB98,

  b2_colorPaleTurquoise = 0xAFEEEE,

  b2_colorPaleVioletRed = 0xDB7093,

  b2_colorPapayaWhip = 0xFFEFD5,

  b2_colorPeachPuff = 0xFFDAB9,

  b2_colorPeru = 0xCD853F,

  b2_colorPink = 0xFFC0CB,

  b2_colorPlum = 0xDDA0DD,

  b2_colorPowderBlue = 0xB0E0E6,

  b2_colorPurple = 0x800080,

  b2_colorRebeccaPurple = 0x663399,

  b2_colorRed = 0xFF0000,

  b2_colorRosyBrown = 0xBC8F8F,

  b2_colorRoyalBlue = 0x4169E1,

  b2_colorSaddleBrown = 0x8B4513,

  b2_colorSalmon = 0xFA8072,

  b2_colorSandyBrown = 0xF4A460,

  b2_colorSeaGreen = 0x2E8B57,

  b2_colorSeaShell = 0xFFF5EE,

  b2_colorSienna = 0xA0522D,

  b2_colorSilver = 0xC0C0C0,

  b2_colorSkyBlue = 0x87CEEB,

  b2_colorSlateBlue = 0x6A5ACD,

  b2_colorSlateGray = 0x708090,

  b2_colorSnow = 0xFFFAFA,

  b2_colorSpringGreen = 0x00FF7F,

  b2_colorSteelBlue = 0x4682B4,

  b2_colorTan = 0xD2B48C,

  b2_colorTeal = 0x008080,

  b2_colorThistle = 0xD8BFD8,

  b2_colorTomato = 0xFF6347,

  b2_colorTurquoise = 0x40E0D0,

  b2_colorViolet = 0xEE82EE,

  b2_colorWheat = 0xF5DEB3,

  b2_colorWhite = 0xFFFFFF,

  b2_colorWhiteSmoke = 0xF5F5F5,

  b2_colorYellow = 0xFFFF00,

  b2_colorYellowGreen = 0x9ACD32,

  b2_colorBox2DRed = 0xDC3132,

  b2_colorBox2DBlue = 0x30AEBF,

  b2_colorBox2DGreen = 0x8CC924,
}

  /// <summary>
  /// Prototype for user allocation function
  /// </summary>
  /// <returns>Original C type: void*</returns>
  /// <param name="size">the allocation size in bytes
  /// (Original C type: unsigned int)</param>
  /// <param name="alignment">the required alignment, guaranteed to be a power of 2
  /// (Original C type: int)</param>
  /// <param name="size">the allocation size in bytes
  /// (Original C type: unsigned int)</param>
  /// <param name="alignment">the required alignment, guaranteed to be a power of 2
  /// (Original C type: int)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate IntPtr /* void* */ b2AllocFcn(uint size, int alignment);

  /// <summary>
  /// Prototype for user free function
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="mem">the memory previously allocated through `b2AllocFcn`
  /// (Original C type: void*)</param>
  /// <param name="mem">the memory previously allocated through `b2AllocFcn`
  /// (Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void b2FreeFcn(IntPtr /* void* */ mem);

  /// <summary>
  /// Prototype for the user assert callback. Return 0 to skip the debugger break.
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="condition">(Original C type: const char*)</param>
  /// <param name="fileName">(Original C type: const char*)</param>
  /// <param name="lineNumber">(Original C type: int)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate int b2AssertFcn(string condition, string fileName, int lineNumber);

  /// <summary>
  /// This function receives proxies found in the AABB query.
  /// @return true if the query should continue
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="proxyId">(Original C type: int)</param>
  /// <param name="userData">(Original C type: uint64_t)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2TreeQueryCallbackFcn(int proxyId, ulong userData, IntPtr /* void* */ context);

  /// <summary>
  /// This function receives clipped ray cast input for a proxy. The function
  /// returns the new ray fraction.
  /// - return a value of 0 to terminate the ray cast
  /// - return a value less than input->maxFraction to clip the ray
  /// - return a value of input->maxFraction to continue the ray cast without clipping
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
  /// <param name="proxyId">(Original C type: int)</param>
  /// <param name="userData">(Original C type: uint64_t)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2TreeRayCastCallbackFcn(in b2RayCastInput input, int proxyId, ulong userData, IntPtr /* void* */ context);

  /// <summary>
  /// This function receives clipped ray cast input for a proxy. The function
  /// returns the new ray fraction.
  /// - return a value of 0 to terminate the ray cast
  /// - return a value less than input->maxFraction to clip the ray
  /// - return a value of input->maxFraction to continue the ray cast without clipping
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="input">(Original C type: const b2ShapeCastInput*)</param>
  /// <param name="proxyId">(Original C type: int)</param>
  /// <param name="userData">(Original C type: uint64_t)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2TreeShapeCastCallbackFcn(in b2ShapeCastInput input, int proxyId, ulong userData, IntPtr /* void* */ context);

  /// <summary>
  /// Task interface
  /// This is prototype for a Box2D task. Your task system is expected to invoke the Box2D task with these arguments.
  /// The task spans a range of the parallel-for: [startIndex, endIndex)
  /// The worker index must correctly identify each worker in the user thread pool, expected in [0, workerCount).
  /// A worker must only exist on only one thread at a time and is analogous to the thread index.
  /// The task context is the context pointer sent from Box2D when it is enqueued.
  /// The startIndex and endIndex are expected in the range [0, itemCount) where itemCount is the argument to b2EnqueueTaskCallback
  /// below. Box2D expects startIndex < endIndex and will execute a loop like this:
  /// 
  /// @code{.c}
  /// for (int i = startIndex; i < endIndex; ++i)
  /// {
  /// DoWork();
  /// }
  /// @endcode
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="startIndex">(Original C type: int)</param>
  /// <param name="endIndex">(Original C type: int)</param>
  /// <param name="workerIndex">(Original C type: uint32_t)</param>
  /// <param name="taskContext">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void b2TaskCallback(int startIndex, int endIndex, uint workerIndex, IntPtr /* void* */ taskContext);

  /// <summary>
  /// These functions can be provided to Box2D to invoke a task system. These are designed to work well with enkiTS.
  /// Returns a pointer to the user's task object. May be nullptr. A nullptr indicates to Box2D that the work was executed
  /// serially within the callback and there is no need to call b2FinishTaskCallback.
  /// The itemCount is the number of Box2D work items that are to be partitioned among workers by the user's task system.
  /// This is essentially a parallel-for. The minRange parameter is a suggestion of the minimum number of items to assign
  /// per worker to reduce overhead. For example, suppose the task is small and that itemCount is 16. A minRange of 8 suggests
  /// that your task system should split the work items among just two workers, even if you have more available.
  /// In general the range [startIndex, endIndex) send to b2TaskCallback should obey:
  /// endIndex - startIndex >= minRange
  /// The exception of course is when itemCount < minRange.
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: void*</returns>
  /// <param name="task">(Original C type: b2TaskCallback*)</param>
  /// <param name="itemCount">(Original C type: int)</param>
  /// <param name="minRange">(Original C type: int)</param>
  /// <param name="taskContext">(Original C type: void*)</param>
  /// <param name="userContext">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate IntPtr /* void* */ b2EnqueueTaskCallback(IntPtr task, int itemCount, int minRange, IntPtr /* void* */ taskContext, IntPtr /* void* */ userContext);

  /// <summary>
  /// Finishes a user task object that wraps a Box2D task.
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="userTask">(Original C type: void*)</param>
  /// <param name="userContext">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void b2FinishTaskCallback(IntPtr /* void* */ userTask, IntPtr /* void* */ userContext);

  /// <summary>
  /// Optional friction mixing callback. This intentionally provides no context objects because this is called
  /// from a worker thread.
  /// @warning This function should not attempt to modify Box2D state or user application state.
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="frictionA">(Original C type: float)</param>
  /// <param name="userMaterialIdA">(Original C type: int)</param>
  /// <param name="frictionB">(Original C type: float)</param>
  /// <param name="userMaterialIdB">(Original C type: int)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2FrictionCallback(float frictionA, int userMaterialIdA, float frictionB, int userMaterialIdB);

  /// <summary>
  /// Optional restitution mixing callback. This intentionally provides no context objects because this is called
  /// from a worker thread.
  /// @warning This function should not attempt to modify Box2D state or user application state.
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="restitutionA">(Original C type: float)</param>
  /// <param name="userMaterialIdA">(Original C type: int)</param>
  /// <param name="restitutionB">(Original C type: float)</param>
  /// <param name="userMaterialIdB">(Original C type: int)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2RestitutionCallback(float restitutionA, int userMaterialIdA, float restitutionB, int userMaterialIdB);

  /// <summary>
  /// Prototype for a contact filter callback.
  /// This is called when a contact pair is considered for collision. This allows you to
  /// perform custom logic to prevent collision between shapes. This is only called if
  /// one of the two shapes has custom filtering enabled.
  /// Notes:
  /// - this function must be thread-safe
  /// - this is only called if one of the two shapes has enabled custom filtering
  /// - this is called only for awake dynamic bodies
  /// Return false if you want to disable the collision
  /// @see b2ShapeDef
  /// @warning Do not attempt to modify the world inside this callback
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeIdA">(Original C type: b2ShapeId)</param>
  /// <param name="shapeIdB">(Original C type: b2ShapeId)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2CustomFilterFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, IntPtr /* void* */ context);

  /// <summary>
  /// Prototype for a pre-solve callback.
  /// This is called after a contact is updated. This allows you to inspect a
  /// contact before it goes to the solver. If you are careful, you can modify the
  /// contact manifold (e.g. modify the normal).
  /// Notes:
  /// - this function must be thread-safe
  /// - this is only called if the shape has enabled pre-solve events
  /// - this is called only for awake dynamic bodies
  /// - this is not called for sensors
  /// - the supplied manifold has impulse values from the previous step
  /// Return false if you want to disable the contact this step
  /// @warning Do not attempt to modify the world inside this callback
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeIdA">(Original C type: b2ShapeId)</param>
  /// <param name="shapeIdB">(Original C type: b2ShapeId)</param>
  /// <param name="point">(Original C type: b2Vec2)</param>
  /// <param name="normal">(Original C type: b2Vec2)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2PreSolveFcn(b2ShapeId shapeIdA, b2ShapeId shapeIdB, Vector2 point, Vector2 normal, IntPtr /* void* */ context);

  /// <summary>
  /// Prototype callback for overlap queries.
  /// Called for each shape found in the query.
  /// @see b2World_OverlapABB
  /// @return false to terminate the query.
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2OverlapResultFcn(b2ShapeId shapeId, IntPtr /* void* */ context);

  /// <summary>
  /// Prototype callback for ray and shape casts.
  /// Called for each shape found in the query. You control how the ray cast
  /// proceeds by returning a float:
  /// return -1: ignore this shape and continue
  /// return 0: terminate the ray cast
  /// return fraction: clip the ray to this point
  /// return 1: don't clip the ray and continue
  /// A cast with initial overlap will return a zero fraction and a zero normal.
  /// @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue
  /// @see b2World_CastRay
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="shapeId">the shape hit by the ray
  /// (Original C type: b2ShapeId)</param>
  /// <param name="point">the point of initial intersection
  /// (Original C type: b2Vec2)</param>
  /// <param name="normal">the normal vector at the point of intersection, zero for a shape cast with initial overlap
  /// (Original C type: b2Vec2)</param>
  /// <param name="fraction">the fraction along the ray at the point of intersection, zero for a shape cast with initial overlap
  /// (Original C type: float)</param>
  /// <param name="context">the user context
  /// (Original C type: void*)</param>
  /// <param name="shapeId">the shape hit by the ray
  /// (Original C type: b2ShapeId)</param>
  /// <param name="point">the point of initial intersection
  /// (Original C type: b2Vec2)</param>
  /// <param name="normal">the normal vector at the point of intersection, zero for a shape cast with initial overlap
  /// (Original C type: b2Vec2)</param>
  /// <param name="fraction">the fraction along the ray at the point of intersection, zero for a shape cast with initial overlap
  /// (Original C type: float)</param>
  /// <param name="context">the user context
  /// (Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate float b2CastResultFcn(b2ShapeId shapeId, Vector2 point, Vector2 normal, float fraction, IntPtr /* void* */ context);

  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="plane">(Original C type: const b2PlaneResult*)</param>
  /// <param name="context">(Original C type: void*)</param>
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate bool b2PlaneResultFcn(b2ShapeId shapeId, in b2PlaneResult plane, IntPtr /* void* */ context);

  /// <summary>
  /// Version numbering scheme.
  /// See https://semver.org/
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Version
{

  /// <summary>
  /// Significant changes
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int major;

  /// <summary>
  /// Incremental changes
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int minor;

  /// <summary>
  /// Bug fixes
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int revision;

  public b2Version(in int major, in int minor, in int revision)
  {
    this.major = major;
    this.minor = minor;
    this.revision = revision;
  }

}

  /// <summary>
  /// Low level ray cast input data
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2RayCastInput
{

  /// <summary>
  /// Start point of the ray cast
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 origin;

  /// <summary>
  /// Translation of the ray cast
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 translation;

  /// <summary>
  /// The maximum fraction of the translation to consider, typically 1
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxFraction;

  public b2RayCastInput(in Vector2 origin, in Vector2 translation, in float maxFraction)
  {
    this.origin = origin;
    this.translation = translation;
    this.maxFraction = maxFraction;
  }

}

  /// <summary>
  /// A distance proxy is used by the GJK algorithm. It encapsulates any shape.
  /// You can provide between 1 and B2_MAX_POLYGON_VERTICES and a radius.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ShapeProxy
{

  /// <summary>
  /// The point cloud
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 points0;
  public Vector2 points1;
  public Vector2 points2;
  public Vector2 points3;
  public Vector2 points4;
  public Vector2 points5;
  public Vector2 points6;
  public Vector2 points7;
  /// <summary>.NET helper to get the inline points by index. </summary>
  public Vector2 points(int idx)
  {
    return idx switch
    {
      0 => points0,
      1 => points1,
      2 => points2,
      3 => points3,
      4 => points4,
      5 => points5,
      6 => points6,
      7 => points7,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 8 points.")
    };
  }

  /// <summary>
  /// The number of points. Must be greater than 0.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int count;

  /// <summary>
  /// The external radius of the point cloud. May be zero.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float radius;
}

  /// <summary>
  /// Low level shape cast input in generic form. This allows casting an arbitrary point
  /// cloud wrap with a radius. For example, a circle is a single point with a non-zero radius.
  /// A capsule is two points with a non-zero radius. A box is four points with a zero radius.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ShapeCastInput
{

  /// <summary>
  /// A generic shape
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxy;

  /// <summary>
  /// The translation of the shape cast
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 translation;

  /// <summary>
  /// The maximum fraction of the translation to consider, typically 1
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxFraction;

  /// <summary>
  /// Allow shape cast to encroach when initially touching. This only works if the radius is greater than zero.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool canEncroach;

  public b2ShapeCastInput(in b2ShapeProxy proxy, in Vector2 translation, in float maxFraction, in bool canEncroach)
  {
    this.proxy = proxy;
    this.translation = translation;
    this.maxFraction = maxFraction;
    this.canEncroach = canEncroach;
  }

}

  /// <summary>
  /// Low level ray cast or shape-cast output data. Returns a zero fraction and normal in the case of initial overlap.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2CastOutput
{

  /// <summary>
  /// The surface normal at the hit point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <summary>
  /// The surface hit point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point;

  /// <summary>
  /// The fraction of the input translation at collision
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float fraction;

  /// <summary>
  /// The number of iterations used
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int iterations;

  /// <summary>
  /// Did the cast hit?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool hit;
}

  /// <summary>
  /// This holds the mass data computed for a shape.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2MassData
{

  /// <summary>
  /// The mass of the shape, usually in kilograms.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float mass;

  /// <summary>
  /// The position of the shape's centroid relative to the shape's origin.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 center;

  /// <summary>
  /// The rotational inertia of the shape about the local origin.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float rotationalInertia;

  public b2MassData(in float mass, in Vector2 center, in float rotationalInertia)
  {
    this.mass = mass;
    this.center = center;
    this.rotationalInertia = rotationalInertia;
  }

}

  /// <summary>
  /// A solid circle
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Circle
{

  /// <summary>
  /// The local center
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 center;

  /// <summary>
  /// The radius
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float radius;

  public b2Circle(in Vector2 center, in float radius)
  {
    this.center = center;
    this.radius = radius;
  }

}

  /// <summary>
  /// A solid capsule can be viewed as two semicircles connected
  /// by a rectangle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Capsule
{

  /// <summary>
  /// Local center of the first semicircle
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 center1;

  /// <summary>
  /// Local center of the second semicircle
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 center2;

  /// <summary>
  /// The radius of the semicircles
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float radius;

  public b2Capsule(in Vector2 center1, in Vector2 center2, in float radius)
  {
    this.center1 = center1;
    this.center2 = center2;
    this.radius = radius;
  }

}

  /// <summary>
  /// A solid convex polygon. It is assumed that the interior of the polygon is to
  /// the left of each edge.
  /// Polygons have a maximum number of vertices equal to B2_MAX_POLYGON_VERTICES.
  /// In most cases you should not need many vertices for a convex polygon.
  /// @warning DO NOT fill this out manually, instead use a helper function like
  /// b2MakePolygon or b2MakeBox.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Polygon
{

  /// <summary>
  /// The polygon vertices
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 vertices0;
  public Vector2 vertices1;
  public Vector2 vertices2;
  public Vector2 vertices3;
  public Vector2 vertices4;
  public Vector2 vertices5;
  public Vector2 vertices6;
  public Vector2 vertices7;
  /// <summary>.NET helper to get the inline vertices by index. </summary>
  public Vector2 vertices(int idx)
  {
    return idx switch
    {
      0 => vertices0,
      1 => vertices1,
      2 => vertices2,
      3 => vertices3,
      4 => vertices4,
      5 => vertices5,
      6 => vertices6,
      7 => vertices7,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 8 vertices.")
    };
  }

  /// <summary>
  /// The outward normal vectors of the polygon sides
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normals0;
  public Vector2 normals1;
  public Vector2 normals2;
  public Vector2 normals3;
  public Vector2 normals4;
  public Vector2 normals5;
  public Vector2 normals6;
  public Vector2 normals7;
  /// <summary>.NET helper to get the inline normals by index. </summary>
  public Vector2 normals(int idx)
  {
    return idx switch
    {
      0 => normals0,
      1 => normals1,
      2 => normals2,
      3 => normals3,
      4 => normals4,
      5 => normals5,
      6 => normals6,
      7 => normals7,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 8 normals.")
    };
  }

  /// <summary>
  /// The centroid of the polygon
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 centroid;

  /// <summary>
  /// The external radius for rounded polygons
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float radius;

  /// <summary>
  /// The number of polygon vertices
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int count;
}

  /// <summary>
  /// A line segment with two-sided collision.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Segment
{

  /// <summary>
  /// The first point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point1;

  /// <summary>
  /// The second point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point2;

  public b2Segment(in Vector2 point1, in Vector2 point2)
  {
    this.point1 = point1;
    this.point2 = point2;
  }

}

  /// <summary>
  /// A line segment with one-sided collision. Only collides on the right side.
  /// Several of these are generated for a chain shape.
  /// ghost1 -> point1 -> point2 -> ghost2
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ChainSegment
{

  /// <summary>
  /// The tail ghost vertex
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 ghost1;

  /// <summary>
  /// The line segment
  /// </summary>
  /// <returns>Original C type: b2Segment</returns>
  public b2Segment segment;

  /// <summary>
  /// The head ghost vertex
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 ghost2;

  /// <summary>
  /// The owning chain shape index (internal usage only)
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int chainId;

  public b2ChainSegment(in Vector2 ghost1, in b2Segment segment, in Vector2 ghost2, in int chainId)
  {
    this.ghost1 = ghost1;
    this.segment = segment;
    this.ghost2 = ghost2;
    this.chainId = chainId;
  }

}

  /// <summary>
  /// A convex hull. Used to create convex polygons.
  /// @warning Do not modify these values directly, instead use b2ComputeHull()
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Hull
{

  /// <summary>
  /// The final points of the hull
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 points0;
  public Vector2 points1;
  public Vector2 points2;
  public Vector2 points3;
  public Vector2 points4;
  public Vector2 points5;
  public Vector2 points6;
  public Vector2 points7;
  /// <summary>.NET helper to get the inline points by index. </summary>
  public Vector2 points(int idx)
  {
    return idx switch
    {
      0 => points0,
      1 => points1,
      2 => points2,
      3 => points3,
      4 => points4,
      5 => points5,
      6 => points6,
      7 => points7,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 8 points.")
    };
  }

  /// <summary>
  /// The number of points
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int count;
}

  /// <summary>
  /// Result of computing the distance between two line segments
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SegmentDistanceResult
{

  /// <summary>
  /// The closest point on the first segment
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 closest1;

  /// <summary>
  /// The closest point on the second segment
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 closest2;

  /// <summary>
  /// The barycentric coordinate on the first segment
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float fraction1;

  /// <summary>
  /// The barycentric coordinate on the second segment
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float fraction2;

  /// <summary>
  /// The squared distance between the closest points
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float distanceSquared;

  public b2SegmentDistanceResult(in Vector2 closest1, in Vector2 closest2, in float fraction1, in float fraction2, in float distanceSquared)
  {
    this.closest1 = closest1;
    this.closest2 = closest2;
    this.fraction1 = fraction1;
    this.fraction2 = fraction2;
    this.distanceSquared = distanceSquared;
  }

}

  /// <summary>
  /// Used to warm start the GJK simplex. If you call this function multiple times with nearby
  /// transforms this might improve performance. Otherwise you can zero initialize this.
  /// The distance cache must be initialized to zero on the first call.
  /// Users should generally just zero initialize this structure for each call.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SimplexCache
{

  /// <summary>
  /// The number of stored simplex points
  /// </summary>
  /// <returns>Original C type: uint16_t</returns>
  public ushort count;

  /// <summary>
  /// The cached simplex indices on shape A
  /// </summary>
  /// <returns>Original C type: uint8_t</returns>
  public byte indexA0;
  public byte indexA1;
  public byte indexA2;
  /// <summary>.NET helper to get the inline indexA by index. </summary>
  public byte indexA(int idx)
  {
    return idx switch
    {
      0 => indexA0,
      1 => indexA1,
      2 => indexA2,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 3 indexA.")
    };
  }

  /// <summary>
  /// The cached simplex indices on shape B
  /// </summary>
  /// <returns>Original C type: uint8_t</returns>
  public byte indexB0;
  public byte indexB1;
  public byte indexB2;
  /// <summary>.NET helper to get the inline indexB by index. </summary>
  public byte indexB(int idx)
  {
    return idx switch
    {
      0 => indexB0,
      1 => indexB1,
      2 => indexB2,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 3 indexB.")
    };
  }
}

  /// <summary>
  /// Input for b2ShapeDistance
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2DistanceInput
{

  /// <summary>
  /// The proxy for shape A
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxyA;

  /// <summary>
  /// The proxy for shape B
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxyB;

  /// <summary>
  /// The world transform for shape A
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform transformA;

  /// <summary>
  /// The world transform for shape B
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform transformB;

  /// <summary>
  /// Should the proxy radius be considered?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool useRadii;

  public b2DistanceInput(in b2ShapeProxy proxyA, in b2ShapeProxy proxyB, in b2Transform transformA, in b2Transform transformB, in bool useRadii)
  {
    this.proxyA = proxyA;
    this.proxyB = proxyB;
    this.transformA = transformA;
    this.transformB = transformB;
    this.useRadii = useRadii;
  }

}

  /// <summary>
  /// Output for b2ShapeDistance
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2DistanceOutput
{

  /// <summary>
  /// Closest point on shapeA
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 pointA;

  /// <summary>
  /// Closest point on shapeB
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 pointB;

  /// <summary>
  /// Normal vector that points from A to B. Invalid if distance is zero.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <summary>
  /// The final distance, zero if overlapped
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float distance;

  /// <summary>
  /// Number of GJK iterations used
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int iterations;

  /// <summary>
  /// The number of simplexes stored in the simplex array
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int simplexCount;
}

  /// <summary>
  /// Simplex vertex for debugging the GJK algorithm
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SimplexVertex
{

  /// <summary>
  /// support point in proxyA
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 wA;

  /// <summary>
  /// support point in proxyB
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 wB;

  /// <summary>
  /// wB - wA
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 w;

  /// <summary>
  /// barycentric coordinate for closest point
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float a;

  /// <summary>
  /// wA index
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int indexA;

  /// <summary>
  /// wB index
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int indexB;

  public b2SimplexVertex(in Vector2 wA, in Vector2 wB, in Vector2 w, in float a, in int indexA, in int indexB)
  {
    this.wA = wA;
    this.wB = wB;
    this.w = w;
    this.a = a;
    this.indexA = indexA;
    this.indexB = indexB;
  }

}

  /// <summary>
  /// Simplex from the GJK algorithm
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Simplex
{

  /// <summary>
  /// vertices
  /// </summary>
  /// <returns>Original C type: b2SimplexVertex</returns>
  public b2SimplexVertex v1;

  /// <summary>
  /// vertices
  /// </summary>
  /// <returns>Original C type: b2SimplexVertex</returns>
  public b2SimplexVertex v2;

  /// <summary>
  /// vertices
  /// </summary>
  /// <returns>Original C type: b2SimplexVertex</returns>
  public b2SimplexVertex v3;

  /// <summary>
  /// number of valid vertices
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int count;

  public b2Simplex(in b2SimplexVertex v1, in b2SimplexVertex v2, in b2SimplexVertex v3, in int count)
  {
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
    this.count = count;
  }

}

  /// <summary>
  /// Input parameters for b2ShapeCast
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ShapeCastPairInput
{

  /// <summary>
  /// The proxy for shape A
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxyA;

  /// <summary>
  /// The proxy for shape B
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxyB;

  /// <summary>
  /// The world transform for shape A
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform transformA;

  /// <summary>
  /// The world transform for shape B
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform transformB;

  /// <summary>
  /// The translation of shape B
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 translationB;

  /// <summary>
  /// The fraction of the translation to consider, typically 1
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxFraction;

  /// <summary>
  /// Allows shapes with a radius to move slightly closer if already touching
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool canEncroach;

  public b2ShapeCastPairInput(in b2ShapeProxy proxyA, in b2ShapeProxy proxyB, in b2Transform transformA, in b2Transform transformB, in Vector2 translationB, in float maxFraction, in bool canEncroach)
  {
    this.proxyA = proxyA;
    this.proxyB = proxyB;
    this.transformA = transformA;
    this.transformB = transformB;
    this.translationB = translationB;
    this.maxFraction = maxFraction;
    this.canEncroach = canEncroach;
  }

}

  /// <summary>
  /// This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin,
  /// which may not coincide with the center of mass. However, to support dynamics we must interpolate the center of mass
  /// position.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Sweep
{

  /// <summary>
  /// Local center of mass position
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 localCenter;

  /// <summary>
  /// Starting center of mass world position
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 c1;

  /// <summary>
  /// Ending center of mass world position
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 c2;

  /// <summary>
  /// Starting world rotation
  /// </summary>
  /// <returns>Original C type: b2Rot</returns>
  public b2Rot q1;

  /// <summary>
  /// Ending world rotation
  /// </summary>
  /// <returns>Original C type: b2Rot</returns>
  public b2Rot q2;

  public b2Sweep(in Vector2 localCenter, in Vector2 c1, in Vector2 c2, in b2Rot q1, in b2Rot q2)
  {
    this.localCenter = localCenter;
    this.c1 = c1;
    this.c2 = c2;
    this.q1 = q1;
    this.q2 = q2;
  }

}

  /// <summary>
  /// Time of impact input
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2TOIInput
{

  /// <summary>
  /// The proxy for shape A
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxyA;

  /// <summary>
  /// The proxy for shape B
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  public b2ShapeProxy proxyB;

  /// <summary>
  /// The movement of shape A
  /// </summary>
  /// <returns>Original C type: b2Sweep</returns>
  public b2Sweep sweepA;

  /// <summary>
  /// The movement of shape B
  /// </summary>
  /// <returns>Original C type: b2Sweep</returns>
  public b2Sweep sweepB;

  /// <summary>
  /// Defines the sweep interval [0, maxFraction]
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxFraction;

  public b2TOIInput(in b2ShapeProxy proxyA, in b2ShapeProxy proxyB, in b2Sweep sweepA, in b2Sweep sweepB, in float maxFraction)
  {
    this.proxyA = proxyA;
    this.proxyB = proxyB;
    this.sweepA = sweepA;
    this.sweepB = sweepB;
    this.maxFraction = maxFraction;
  }

}

  /// <summary>
  /// Time of impact output
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2TOIOutput
{

  /// <summary>
  /// The type of result
  /// </summary>
  /// <returns>Original C type: b2TOIState</returns>
  public b2TOIState state;

  /// <summary>
  /// The hit point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point;

  /// <summary>
  /// The hit normal
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <summary>
  /// The sweep time of the collision
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float fraction;
}

  /// <summary>
  /// A manifold point is a contact point belonging to a contact manifold.
  /// It holds details related to the geometry and dynamics of the contact points.
  /// Box2D uses speculative collision so some contact points may be separated.
  /// You may use the totalNormalImpulse to determine if there was an interaction during
  /// the time step.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ManifoldPoint
{

  /// <summary>
  /// Location of the contact point in world space. Subject to precision loss at large coordinates.
  /// @note Should only be used for debugging.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point;

  /// <summary>
  /// Location of the contact point relative to shapeA's origin in world space
  /// @note When used internally to the Box2D solver, this is relative to the body center of mass.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 anchorA;

  /// <summary>
  /// Location of the contact point relative to shapeB's origin in world space
  /// @note When used internally to the Box2D solver, this is relative to the body center of mass.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 anchorB;

  /// <summary>
  /// The separation of the contact point, negative if penetrating
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float separation;

  /// <summary>
  /// The impulse along the manifold normal vector.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float normalImpulse;

  /// <summary>
  /// The friction impulse
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float tangentImpulse;

  /// <summary>
  /// The total normal impulse applied across sub-stepping and restitution. This is important
  /// to identify speculative contact points that had an interaction in the time step.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float totalNormalImpulse;

  /// <summary>
  /// Relative normal velocity pre-solve. Used for hit events. If the normal impulse is
  /// zero then there was no hit. Negative means shapes are approaching.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float normalVelocity;

  /// <summary>
  /// Uniquely identifies a contact point between two shapes
  /// </summary>
  /// <returns>Original C type: uint16_t</returns>
  public ushort id;

  /// <summary>
  /// Did this contact point exist the previous step?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool persisted;

  public b2ManifoldPoint(in Vector2 point, in Vector2 anchorA, in Vector2 anchorB, in float separation, in float normalImpulse, in float tangentImpulse, in float totalNormalImpulse, in float normalVelocity, in ushort id, in bool persisted)
  {
    this.point = point;
    this.anchorA = anchorA;
    this.anchorB = anchorB;
    this.separation = separation;
    this.normalImpulse = normalImpulse;
    this.tangentImpulse = tangentImpulse;
    this.totalNormalImpulse = totalNormalImpulse;
    this.normalVelocity = normalVelocity;
    this.id = id;
    this.persisted = persisted;
  }

}

  /// <summary>
  /// A contact manifold describes the contact points between colliding shapes.
  /// @note Box2D uses speculative collision so some contact points may be separated.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Manifold
{

  /// <summary>
  /// The unit normal vector in world space, points from shape A to bodyB
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <summary>
  /// Angular impulse applied for rolling resistance. N * m * s = kg * m^2 / s
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float rollingImpulse;

  /// <summary>
  /// The manifold points, up to two are possible in 2D
  /// </summary>
  /// <returns>Original C type: b2ManifoldPoint</returns>
  public b2ManifoldPoint points0;
  public b2ManifoldPoint points1;
  /// <summary>.NET helper to get the inline points by index. </summary>
  public b2ManifoldPoint points(int idx)
  {
    return idx switch
    {
      0 => points0,
      1 => points1,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 2 points.")
    };
  }

  /// <summary>
  /// The number of contacts points, will be 0, 1, or 2
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int pointCount;
}

  /// <summary>
  /// These are performance results returned by dynamic tree queries.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2TreeStats
{

  /// <summary>
  /// Number of internal nodes visited during the query
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int nodeVisits;

  /// <summary>
  /// Number of leaf nodes visited during the query
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int leafVisits;

  public b2TreeStats(in int nodeVisits, in int leafVisits)
  {
    this.nodeVisits = nodeVisits;
    this.leafVisits = leafVisits;
  }

}

  /// <summary>
  /// These are the collision planes returned from b2World_CollideMover
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2PlaneResult
{

  /// <summary>
  /// The collision plane between the mover and a convex shape
  /// </summary>
  /// <returns>Original C type: b2Plane</returns>
  public b2Plane plane;

  /// <summary>
  /// The collision point on the shape.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point;

  /// <summary>
  /// Did the collision register a hit? If not this plane should be ignored.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool hit;

  public b2PlaneResult(in b2Plane plane, in Vector2 point, in bool hit)
  {
    this.plane = plane;
    this.point = point;
    this.hit = hit;
  }

}

  /// <summary>
  /// These are collision planes that can be fed to b2SolvePlanes. Normally
  /// this is assembled by the user from plane results in b2PlaneResult
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2CollisionPlane
{

  /// <summary>
  /// The collision plane between the mover and some shape
  /// </summary>
  /// <returns>Original C type: b2Plane</returns>
  public b2Plane plane;

  /// <summary>
  /// Setting this to FLT_MAX makes the plane as rigid as possible. Lower values can
  /// make the plane collision soft. Usually in meters.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float pushLimit;

  /// <summary>
  /// The push on the mover determined by b2SolvePlanes. Usually in meters.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float push;

  /// <summary>
  /// Indicates if b2ClipVector should clip against this plane. Should be false for soft collision.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool clipVelocity;

  public b2CollisionPlane(in b2Plane plane, in float pushLimit, in float push, in bool clipVelocity)
  {
    this.plane = plane;
    this.pushLimit = pushLimit;
    this.push = push;
    this.clipVelocity = clipVelocity;
  }

}

  /// <summary>
  /// Result returned by b2SolvePlanes
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2PlaneSolverResult
{

  /// <summary>
  /// The translation of the mover
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 translation;

  /// <summary>
  /// The number of iterations used by the plane solver. For diagnostics.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int iterationCount;

  public b2PlaneSolverResult(in Vector2 translation, in int iterationCount)
  {
    this.translation = translation;
    this.iterationCount = iterationCount;
  }

}

  /// <summary>
  /// World id references a world instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2WorldId
{

  /// <returns>Original C type: uint16_t</returns>
  public ushort index1;

  /// <returns>Original C type: uint16_t</returns>
  public ushort generation;
}

  /// <summary>
  /// Body id references a body instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2BodyId
{

  /// <returns>Original C type: int32_t</returns>
  public int index1;

  /// <returns>Original C type: uint16_t</returns>
  public ushort world0;

  /// <returns>Original C type: uint16_t</returns>
  public ushort generation;
}

  /// <summary>
  /// Shape id references a shape instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ShapeId
{

  /// <returns>Original C type: int32_t</returns>
  public int index1;

  /// <returns>Original C type: uint16_t</returns>
  public ushort world0;

  /// <returns>Original C type: uint16_t</returns>
  public ushort generation;
}

  /// <summary>
  /// Chain id references a chain instances. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ChainId
{

  /// <returns>Original C type: int32_t</returns>
  public int index1;

  /// <returns>Original C type: uint16_t</returns>
  public ushort world0;

  /// <returns>Original C type: uint16_t</returns>
  public ushort generation;
}

  /// <summary>
  /// Joint id references a joint instance. This should be treated as an opaque handle.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2JointId
{

  /// <returns>Original C type: int32_t</returns>
  public int index1;

  /// <returns>Original C type: uint16_t</returns>
  public ushort world0;

  /// <returns>Original C type: uint16_t</returns>
  public ushort generation;
}

  /// <summary>
  /// Contact id references a contact instance. This should be treated as an opaque handled.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ContactId
{

  /// <returns>Original C type: int32_t</returns>
  public int index1;

  /// <returns>Original C type: uint16_t</returns>
  public ushort world0;

  /// <returns>Original C type: int16_t</returns>
  public short padding;

  /// <returns>Original C type: uint32_t</returns>
  public uint generation;
}

  /// <summary>
  /// Cosine and sine pair
  /// This uses a custom implementation designed for cross-platform determinism
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2CosSin
{

  /// <summary>
  /// cosine and sine
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float cosine;

  /// <returns>Original C type: float</returns>
  public float sine;

  public b2CosSin(in float cosine, in float sine)
  {
    this.cosine = cosine;
    this.sine = sine;
  }

}

  /// <summary>
  /// 2D rotation
  /// This is similar to using a complex number for rotation
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Rot
{

  /// <summary>
  /// cosine and sine
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float c;

  /// <summary>
  /// cosine and sine
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float s;

  public b2Rot(in float c, in float s)
  {
    this.c = c;
    this.s = s;
  }

}

  /// <summary>
  /// A 2D rigid transform
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Transform
{

  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 p;

  /// <returns>Original C type: b2Rot</returns>
  public b2Rot q;

  public b2Transform(in Vector2 p, in b2Rot q)
  {
    this.p = p;
    this.q = q;
  }

}

  /// <summary>
  /// A 2-by-2 Matrix
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Mat22
{

  /// <summary>
  /// columns
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 cx;

  /// <summary>
  /// columns
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 cy;

  public b2Mat22(in Vector2 cx, in Vector2 cy)
  {
    this.cx = cx;
    this.cy = cy;
  }

}

  /// <summary>
  /// Axis-aligned bounding box
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2AABB
{

  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 lowerBound;

  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 upperBound;

  public b2AABB(in Vector2 lowerBound, in Vector2 upperBound)
  {
    this.lowerBound = lowerBound;
    this.upperBound = upperBound;
  }

}

  /// <summary>
  /// separation = dot(normal, point) - offset
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Plane
{

  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <returns>Original C type: float</returns>
  public float offset;

  public b2Plane(in Vector2 normal, in float offset)
  {
    this.normal = normal;
    this.offset = offset;
  }

}

  /// <summary>
  /// Result from b2World_RayCastClosest
  /// If there is initial overlap the fraction and normal will be zero while the point is an arbitrary point in the overlap region.
  /// @ingroup world
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2RayResult
{

  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeId;

  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point;

  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <returns>Original C type: float</returns>
  public float fraction;

  /// <returns>Original C type: int</returns>
  public int nodeVisits;

  /// <returns>Original C type: int</returns>
  public int leafVisits;

  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool hit;

  public b2RayResult(in b2ShapeId shapeId, in Vector2 point, in Vector2 normal, in float fraction, in int nodeVisits, in int leafVisits, in bool hit)
  {
    this.shapeId = shapeId;
    this.point = point;
    this.normal = normal;
    this.fraction = fraction;
    this.nodeVisits = nodeVisits;
    this.leafVisits = leafVisits;
    this.hit = hit;
  }

}

  /// <summary>
  /// World definition used to create a simulation world.
  /// Must be initialized using b2DefaultWorldDef().
  /// @ingroup world
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2WorldDef
{

  /// <summary>
  /// Gravity vector. Box2D has no up-vector defined.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 gravity;

  /// <summary>
  /// Restitution speed threshold, usually in m/s. Collisions above this
  /// speed have restitution applied (will bounce).
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float restitutionThreshold;

  /// <summary>
  /// Threshold speed for hit events. Usually meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float hitEventThreshold;

  /// <summary>
  /// Contact stiffness. Cycles per second. Increasing this increases the speed of overlap recovery, but can introduce jitter.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float contactHertz;

  /// <summary>
  /// Contact bounciness. Non-dimensional. You can speed up overlap recovery by decreasing this with
  /// the trade-off that overlap resolution becomes more energetic.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float contactDampingRatio;

  /// <summary>
  /// This parameter controls how fast overlap is resolved and usually has units of meters per second. This only
  /// puts a cap on the resolution speed. The resolution speed is increased by increasing the hertz and/or
  /// decreasing the damping ratio.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float contactSpeed;

  /// <summary>
  /// Maximum linear speed. Usually meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maximumLinearSpeed;

  /// <summary>
  /// Optional mixing callback for friction. The default uses sqrt(frictionA * frictionB).
  /// </summary>
  /// <returns>Original C type: b2FrictionCallback*</returns>
  public IntPtr frictionCallback;

  /// <summary>
  /// Optional mixing callback for restitution. The default uses max(restitutionA, restitutionB).
  /// </summary>
  /// <returns>Original C type: b2RestitutionCallback*</returns>
  public IntPtr restitutionCallback;

  /// <summary>
  /// Can bodies go to sleep to improve performance
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSleep;

  /// <summary>
  /// Enable continuous collision
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableContinuous;

  /// <summary>
  /// Number of workers to use with the provided task system. Box2D performs best when using only
  /// performance cores and accessing a single L2 cache. Efficiency cores and hyper-threading provide
  /// little benefit and may even harm performance.
  /// @note Box2D does not create threads. This is the number of threads your applications has created
  /// that you are allocating to b2World_Step.
  /// @warning Do not modify the default value unless you are also providing a task system and providing
  /// task callbacks (enqueueTask and finishTask).
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int workerCount;

  /// <summary>
  /// Function to spawn tasks
  /// </summary>
  /// <returns>Original C type: b2EnqueueTaskCallback*</returns>
  public IntPtr enqueueTask;

  /// <summary>
  /// Function to finish a task
  /// </summary>
  /// <returns>Original C type: b2FinishTaskCallback*</returns>
  public IntPtr finishTask;

  /// <summary>
  /// User context that is provided to enqueueTask and finishTask
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userTaskContext;

  /// <summary>
  /// User data
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Motion locks to restrict the body movement
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2MotionLocks
{

  /// <summary>
  /// Prevent translation along the x-axis
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool linearX;

  /// <summary>
  /// Prevent translation along the y-axis
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool linearY;

  /// <summary>
  /// Prevent rotation around the z-axis
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool angularZ;

  public b2MotionLocks(in bool linearX, in bool linearY, in bool angularZ)
  {
    this.linearX = linearX;
    this.linearY = linearY;
    this.angularZ = angularZ;
  }

}

  /// <summary>
  /// A body definition holds all the data needed to construct a rigid body.
  /// You can safely re-use body definitions. Shapes are added to a body after construction.
  /// Body definitions are temporary objects used to bundle creation parameters.
  /// Must be initialized using b2DefaultBodyDef().
  /// @ingroup body
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2BodyDef
{

  /// <summary>
  /// The body type: static, kinematic, or dynamic.
  /// </summary>
  /// <returns>Original C type: b2BodyType</returns>
  public b2BodyType type;

  /// <summary>
  /// The initial world position of the body. Bodies should be created with the desired position.
  /// @note Creating bodies at the origin and then moving them nearly doubles the cost of body creation, especially
  /// if the body is moved after shapes have been added.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 position;

  /// <summary>
  /// The initial world rotation of the body. Use b2MakeRot() if you have an angle.
  /// </summary>
  /// <returns>Original C type: b2Rot</returns>
  public b2Rot rotation;

  /// <summary>
  /// The initial linear velocity of the body's origin. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 linearVelocity;

  /// <summary>
  /// The initial angular velocity of the body. Radians per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float angularVelocity;

  /// <summary>
  /// Linear damping is used to reduce the linear velocity. The damping parameter
  /// can be larger than 1 but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  /// Generally linear damping is undesirable because it makes objects move slowly
  /// as if they are floating.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float linearDamping;

  /// <summary>
  /// Angular damping is used to reduce the angular velocity. The damping parameter
  /// can be larger than 1.0f but the damping effect becomes sensitive to the
  /// time step when the damping parameter is large.
  /// Angular damping can be use slow down rotating bodies.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float angularDamping;

  /// <summary>
  /// Scale the gravity applied to this body. Non-dimensional.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float gravityScale;

  /// <summary>
  /// Sleep speed threshold, default is 0.05 meters per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float sleepThreshold;

  /// <summary>
  /// Optional body name for debugging. Up to 31 characters (excluding null termination)
  /// </summary>
  /// <returns>Original C type: const char*</returns>
  public string name;

  /// <summary>
  /// Use this to store application specific body data.
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// Motions locks to restrict linear and angular movement
  /// </summary>
  /// <returns>Original C type: b2MotionLocks</returns>
  public b2MotionLocks motionLocks;

  /// <summary>
  /// Set this flag to false if this body should never fall asleep.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSleep;

  /// <summary>
  /// Is this body initially awake or sleeping?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool isAwake;

  /// <summary>
  /// Treat this body as high speed object that performs continuous collision detection
  /// against dynamic and kinematic bodies, but not other bullet bodies.
  /// @warning Bullets should be used sparingly. They are not a solution for general dynamic-versus-dynamic
  /// continuous collision.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool isBullet;

  /// <summary>
  /// Option to perform continuous collision checks with sensors. This only applies to dynamic bodies.
  /// This is expensive and should be used sparingly. You still need to enable sensor events on the child shapes
  /// for this to work. This only works if the body is awake. This will use a time of impact calculation to
  /// generate sensor begin touch events, but not end events. End events are handled using regular overlap checks.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSensorHits;

  /// <summary>
  /// Used to disable a body. A disabled body does not move or collide.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool isEnabled;

  /// <summary>
  /// This allows this body to bypass rotational speed limits. Should only be used
  /// for circular objects, like wheels.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool allowFastRotation;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// This is used to filter collision on shapes. It affects shape-vs-shape collision
  /// and shape-versus-query collision (such as b2World_CastRay).
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Filter
{

  /// <summary>
  /// The collision category bits. Normally you would just set one bit. The category bits should
  /// represent your application object types. For example:
  /// @code{.cpp}
  /// enum MyCategories
  /// {
  /// Static  = 0x00000001,
  /// Dynamic = 0x00000002,
  /// Debris  = 0x00000004,
  /// Player  = 0x00000008,
  /// // etc
  /// };
  /// @endcode
  /// </summary>
  /// <returns>Original C type: uint64_t</returns>
  public ulong categoryBits;

  /// <summary>
  /// The collision mask bits. This states the categories that this
  /// shape would accept for collision.
  /// For example, you may want your player to only collide with static objects
  /// and other players.
  /// @code{.c}
  /// maskBits = Static | Player;
  /// @endcode
  /// </summary>
  /// <returns>Original C type: uint64_t</returns>
  public ulong maskBits;

  /// <summary>
  /// Collision groups allow a certain group of objects to never collide (negative)
  /// or always collide (positive). A group index of zero has no effect. Non-zero group filtering
  /// always wins against the mask bits.
  /// For example, you may want ragdolls to collide with other ragdolls but you don't want
  /// ragdoll self-collision. In this case you would give each ragdoll a unique negative group index
  /// and apply that group index to all shapes on the ragdoll.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int groupIndex;

  public b2Filter(in ulong categoryBits, in ulong maskBits, in int groupIndex)
  {
    this.categoryBits = categoryBits;
    this.maskBits = maskBits;
    this.groupIndex = groupIndex;
  }

}

  /// <summary>
  /// The query filter is used to filter collisions between queries and shapes. For example,
  /// you may want a ray-cast representing a projectile to hit players and the static environment
  /// but not debris.
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2QueryFilter
{

  /// <summary>
  /// The collision category bits of this query. Normally you would just set one bit.
  /// </summary>
  /// <returns>Original C type: uint64_t</returns>
  public ulong categoryBits;

  /// <summary>
  /// The collision mask bits. This states the shape categories that this
  /// query would accept for collision.
  /// </summary>
  /// <returns>Original C type: uint64_t</returns>
  public ulong maskBits;

  public b2QueryFilter(in ulong categoryBits, in ulong maskBits)
  {
    this.categoryBits = categoryBits;
    this.maskBits = maskBits;
  }

}

  /// <summary>
  /// Surface materials allow chain shapes to have per segment surface properties.
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SurfaceMaterial
{

  /// <summary>
  /// The Coulomb (dry) friction coefficient, usually in the range [0,1].
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float friction;

  /// <summary>
  /// The coefficient of restitution (bounce) usually in the range [0,1].
  /// https://en.wikipedia.org/wiki/Coefficient_of_restitution
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float restitution;

  /// <summary>
  /// The rolling resistance usually in the range [0,1].
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float rollingResistance;

  /// <summary>
  /// The tangent speed for conveyor belts
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float tangentSpeed;

  /// <summary>
  /// User material identifier. This is passed with query results and to friction and restitution
  /// combining functions. It is not used internally.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int userMaterialId;

  /// <summary>
  /// Custom debug draw color.
  /// </summary>
  /// <returns>Original C type: uint32_t</returns>
  public uint customColor;

  public b2SurfaceMaterial(in float friction, in float restitution, in float rollingResistance, in float tangentSpeed, in int userMaterialId, in uint customColor)
  {
    this.friction = friction;
    this.restitution = restitution;
    this.rollingResistance = rollingResistance;
    this.tangentSpeed = tangentSpeed;
    this.userMaterialId = userMaterialId;
    this.customColor = customColor;
  }

}

  /// <summary>
  /// Used to create a shape.
  /// This is a temporary object used to bundle shape creation parameters. You may use
  /// the same shape definition to create multiple shapes.
  /// Must be initialized using b2DefaultShapeDef().
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ShapeDef
{

  /// <summary>
  /// Use this to store application specific shape data.
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// The surface material for this shape.
  /// </summary>
  /// <returns>Original C type: b2SurfaceMaterial</returns>
  public b2SurfaceMaterial material;

  /// <summary>
  /// The density, usually in kg/m^2.
  /// This is not part of the surface material because this is for the interior, which may have
  /// other considerations, such as being hollow. For example a wood barrel may be hollow or full of water.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float density;

  /// <summary>
  /// Collision filtering data.
  /// </summary>
  /// <returns>Original C type: b2Filter</returns>
  public b2Filter filter;

  /// <summary>
  /// A sensor shape generates overlap events but never generates a collision response.
  /// Sensors do not have continuous collision. Instead, use a ray or shape cast for those scenarios.
  /// Sensors still contribute to the body mass if they have non-zero density.
  /// @note Sensor events are disabled by default.
  /// @see enableSensorEvents
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool isSensor;

  /// <summary>
  /// Enable sensor events for this shape. This applies to sensors and non-sensors. False by default, even for sensors.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSensorEvents;

  /// <summary>
  /// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors. False by default.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableContactEvents;

  /// <summary>
  /// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors. False by default.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableHitEvents;

  /// <summary>
  /// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
  /// and must be carefully handled due to multithreading. Ignored for sensors.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enablePreSolveEvents;

  /// <summary>
  /// When shapes are created they will scan the environment for collision the next time step. This can significantly slow down
  /// static body creation when there are many static shapes.
  /// This is flag is ignored for dynamic and kinematic shapes which always invoke contact creation.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool invokeContactCreation;

  /// <summary>
  /// Should the body update the mass properties when this shape is created. Default is true.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool updateBodyMass;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Used to create a chain of line segments. This is designed to eliminate ghost collisions with some limitations.
  /// - chains are one-sided
  /// - chains have no mass and should be used on static bodies
  /// - chains have a counter-clockwise winding order (normal points right of segment direction)
  /// - chains are either a loop or open
  /// - a chain must have at least 4 points
  /// - the distance between any two points must be greater than B2_LINEAR_SLOP
  /// - a chain shape should not self intersect (this is not validated)
  /// - an open chain shape has NO COLLISION on the first and final edge
  /// - you may overlap two open chains on their first three and/or last three points to get smooth collision
  /// - a chain shape creates multiple line segment shapes on the body
  /// https://en.wikipedia.org/wiki/Polygonal_chain
  /// Must be initialized using b2DefaultChainDef().
  /// @warning Do not use chain shapes unless you understand the limitations. This is an advanced feature.
  /// @ingroup shape
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ChainDef
{

  /// <summary>
  /// Use this to store application specific shape data.
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// An array of at least 4 points. These are cloned and may be temporary.
  /// </summary>
  /// <returns>Original C type: const b2Vec2*</returns>
  public IntPtr points;

  /// <summary>
  /// The point count, must be 4 or more.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int count;

  /// <summary>
  /// Surface materials for each segment. These are cloned.
  /// </summary>
  /// <returns>Original C type: const b2SurfaceMaterial*</returns>
  public IntPtr materials;

  /// <summary>
  /// The material count. Must be 1 or count. This allows you to provide one
  /// material for all segments or a unique material per segment.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int materialCount;

  /// <summary>
  /// Contact filtering data.
  /// </summary>
  /// <returns>Original C type: b2Filter</returns>
  public b2Filter filter;

  /// <summary>
  /// Indicates a closed chain formed by connecting the first and last points
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool isLoop;

  /// <summary>
  /// Enable sensors to detect this chain. False by default.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSensorEvents;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Profiling data. Times are in milliseconds.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Profile
{

  /// <returns>Original C type: float</returns>
  public float step;

  /// <returns>Original C type: float</returns>
  public float pairs;

  /// <returns>Original C type: float</returns>
  public float collide;

  /// <returns>Original C type: float</returns>
  public float solve;

  /// <returns>Original C type: float</returns>
  public float mergeIslands;

  /// <returns>Original C type: float</returns>
  public float prepareStages;

  /// <returns>Original C type: float</returns>
  public float solveConstraints;

  /// <returns>Original C type: float</returns>
  public float prepareConstraints;

  /// <returns>Original C type: float</returns>
  public float integrateVelocities;

  /// <returns>Original C type: float</returns>
  public float warmStart;

  /// <returns>Original C type: float</returns>
  public float solveImpulses;

  /// <returns>Original C type: float</returns>
  public float integratePositions;

  /// <returns>Original C type: float</returns>
  public float relaxImpulses;

  /// <returns>Original C type: float</returns>
  public float applyRestitution;

  /// <returns>Original C type: float</returns>
  public float storeImpulses;

  /// <returns>Original C type: float</returns>
  public float splitIslands;

  /// <returns>Original C type: float</returns>
  public float transforms;

  /// <returns>Original C type: float</returns>
  public float sensorHits;

  /// <returns>Original C type: float</returns>
  public float jointEvents;

  /// <returns>Original C type: float</returns>
  public float hitEvents;

  /// <returns>Original C type: float</returns>
  public float refit;

  /// <returns>Original C type: float</returns>
  public float bullets;

  /// <returns>Original C type: float</returns>
  public float sleepIslands;

  /// <returns>Original C type: float</returns>
  public float sensors;

  public b2Profile(in float step, in float pairs, in float collide, in float solve, in float mergeIslands, in float prepareStages, in float solveConstraints, in float prepareConstraints, in float integrateVelocities, in float warmStart, in float solveImpulses, in float integratePositions, in float relaxImpulses, in float applyRestitution, in float storeImpulses, in float splitIslands, in float transforms, in float sensorHits, in float jointEvents, in float hitEvents, in float refit, in float bullets, in float sleepIslands, in float sensors)
  {
    this.step = step;
    this.pairs = pairs;
    this.collide = collide;
    this.solve = solve;
    this.mergeIslands = mergeIslands;
    this.prepareStages = prepareStages;
    this.solveConstraints = solveConstraints;
    this.prepareConstraints = prepareConstraints;
    this.integrateVelocities = integrateVelocities;
    this.warmStart = warmStart;
    this.solveImpulses = solveImpulses;
    this.integratePositions = integratePositions;
    this.relaxImpulses = relaxImpulses;
    this.applyRestitution = applyRestitution;
    this.storeImpulses = storeImpulses;
    this.splitIslands = splitIslands;
    this.transforms = transforms;
    this.sensorHits = sensorHits;
    this.jointEvents = jointEvents;
    this.hitEvents = hitEvents;
    this.refit = refit;
    this.bullets = bullets;
    this.sleepIslands = sleepIslands;
    this.sensors = sensors;
  }

}

  /// <summary>
  /// Counters that give details of the simulation size.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2Counters
{

  /// <returns>Original C type: int</returns>
  public int bodyCount;

  /// <returns>Original C type: int</returns>
  public int shapeCount;

  /// <returns>Original C type: int</returns>
  public int contactCount;

  /// <returns>Original C type: int</returns>
  public int jointCount;

  /// <returns>Original C type: int</returns>
  public int islandCount;

  /// <returns>Original C type: int</returns>
  public int stackUsed;

  /// <returns>Original C type: int</returns>
  public int staticTreeHeight;

  /// <returns>Original C type: int</returns>
  public int treeHeight;

  /// <returns>Original C type: int</returns>
  public int byteCount;

  /// <returns>Original C type: int</returns>
  public int taskCount;

  /// <returns>Original C type: int</returns>
  public int colorCounts0;
  public int colorCounts1;
  public int colorCounts2;
  public int colorCounts3;
  public int colorCounts4;
  public int colorCounts5;
  public int colorCounts6;
  public int colorCounts7;
  public int colorCounts8;
  public int colorCounts9;
  public int colorCounts10;
  public int colorCounts11;
  /// <summary>.NET helper to get the inline colorCounts by index. </summary>
  public int colorCounts(int idx)
  {
    return idx switch
    {
      0 => colorCounts0,
      1 => colorCounts1,
      2 => colorCounts2,
      3 => colorCounts3,
      4 => colorCounts4,
      5 => colorCounts5,
      6 => colorCounts6,
      7 => colorCounts7,
      8 => colorCounts8,
      9 => colorCounts9,
      10 => colorCounts10,
      11 => colorCounts11,
      _ => throw new ArgumentOutOfRangeException(nameof(idx), "There are only 12 colorCounts.")
    };
  }
}

  /// <summary>
  /// Base joint definition used by all joint types.
  /// The local frames are measured from the body's origin rather than the center of mass because:
  /// 1. you might not know where the center of mass will be
  /// 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2JointDef
{

  /// <summary>
  /// User data pointer
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  /// <summary>
  /// The first attached body
  /// </summary>
  /// <returns>Original C type: b2BodyId</returns>
  public b2BodyId bodyIdA;

  /// <summary>
  /// The second attached body
  /// </summary>
  /// <returns>Original C type: b2BodyId</returns>
  public b2BodyId bodyIdB;

  /// <summary>
  /// The first local joint frame
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform localFrameA;

  /// <summary>
  /// The second local joint frame
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform localFrameB;

  /// <summary>
  /// Force threshold for joint events
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float forceThreshold;

  /// <summary>
  /// Torque threshold for joint events
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float torqueThreshold;

  /// <summary>
  /// Constraint hertz (advanced feature)
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float constraintHertz;

  /// <summary>
  /// Constraint damping ratio (advanced feature)
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float constraintDampingRatio;

  /// <summary>
  /// Debug draw scale
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float drawScale;

  /// <summary>
  /// Set this flag to true if the attached bodies should collide
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool collideConnected;
}

  /// <summary>
  /// Distance joint definition
  /// Connects a point on body A with a point on body B by a segment.
  /// Useful for ropes and springs.
  /// @ingroup distance_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2DistanceJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// The rest length of this joint. Clamped to a stable minimum value.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float length;

  /// <summary>
  /// Enable the distance constraint to behave like a spring. If false
  /// then the distance joint will be rigid, overriding the limit and motor.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// The spring linear stiffness Hertz, cycles per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float hertz;

  /// <summary>
  /// The spring linear damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float dampingRatio;

  /// <summary>
  /// Enable/disable the joint limit
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// Minimum length. Clamped to a stable minimum value.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float minLength;

  /// <summary>
  /// Maximum length. Must be greater than or equal to the minimum length.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxLength;

  /// <summary>
  /// Enable/disable the joint motor
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxMotorForce;

  /// <summary>
  /// The desired motor speed, usually in meters per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float motorSpeed;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// A motor joint is used to control the relative motion between two bodies
  /// You may move local frame A to change the target transform.
  /// A typical usage is to control the movement of a dynamic body with respect to the ground.
  /// @ingroup motor_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2MotorJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// The maximum motor force in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxForce;

  /// <summary>
  /// The maximum motor torque in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxTorque;

  /// <summary>
  /// Position correction factor in the range [0,1]
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float correctionFactor;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// A mouse joint is used to make a point on body B track a point on body A.
  /// You may move local frame A to change the target point.
  /// This a soft constraint and allows the constraint to stretch without
  /// applying huge forces. This also applies rotation constraint heuristic to improve control.
  /// @ingroup mouse_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2MouseJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// Stiffness in hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float hertz;

  /// <summary>
  /// Damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float dampingRatio;

  /// <summary>
  /// Maximum force, typically in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxForce;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// A filter joint is used to disable collision between two specific bodies.
  /// 
  /// @ingroup filter_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2FilterJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Prismatic joint definition
  /// Body B may slide along the x-axis in local frame A. Body B cannot rotate relative to body A.
  /// The joint translation is zero when the local frame origins coincide in world space.
  /// @ingroup prismatic_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2PrismaticJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// Enable a linear spring along the prismatic joint axis
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// The spring stiffness Hertz, cycles per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float hertz;

  /// <summary>
  /// The spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float dampingRatio;

  /// <summary>
  /// The target translation for the joint in meters. The spring-damper will drive
  /// to this translation.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float targetTranslation;

  /// <summary>
  /// Enable/disable the joint limit
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// The lower translation limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float lowerTranslation;

  /// <summary>
  /// The upper translation limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float upperTranslation;

  /// <summary>
  /// Enable/disable the joint motor
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor force, typically in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxMotorForce;

  /// <summary>
  /// The desired motor speed, typically in meters per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float motorSpeed;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Revolute joint definition
  /// A point on body B is fixed to a point on body A. Allows relative rotation.
  /// @ingroup revolute_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2RevoluteJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// The target angle for the joint in radians. The spring-damper will drive
  /// to this angle.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float targetAngle;

  /// <summary>
  /// Enable a rotational spring on the revolute hinge axis
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// The spring stiffness Hertz, cycles per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float hertz;

  /// <summary>
  /// The spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float dampingRatio;

  /// <summary>
  /// A flag to enable joint limits
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// The lower angle for the joint limit in radians. Minimum of -0.99*pi radians.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float lowerAngle;

  /// <summary>
  /// The upper angle for the joint limit in radians. Maximum of 0.99*pi radians.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float upperAngle;

  /// <summary>
  /// A flag to enable the joint motor
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor torque, typically in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxMotorTorque;

  /// <summary>
  /// The desired motor speed in radians per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float motorSpeed;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Weld joint definition
  /// Connects two bodies together rigidly. This constraint provides springs to mimic
  /// soft-body simulation.
  /// @note The approximate solver in Box2D cannot hold many bodies together rigidly
  /// @ingroup weld_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2WeldJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// Linear stiffness expressed as Hertz (cycles per second). Use zero for maximum stiffness.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float linearHertz;

  /// <summary>
  /// Angular stiffness as Hertz (cycles per second). Use zero for maximum stiffness.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float angularHertz;

  /// <summary>
  /// Linear damping ratio, non-dimensional. Use 1 for critical damping.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float linearDampingRatio;

  /// <summary>
  /// Linear damping ratio, non-dimensional. Use 1 for critical damping.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float angularDampingRatio;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// Wheel joint definition
  /// Body B is a wheel that may rotate freely and slide along the local x-axis in frame A.
  /// The joint translation is zero when the local frame origins coincide in world space.
  /// @ingroup wheel_joint
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2WheelJointDef
{

  /// <summary>
  /// Base joint definition
  /// </summary>
  /// <returns>Original C type: b2JointDef</returns>
  public b2JointDef @base;

  /// <summary>
  /// Enable a linear spring along the local axis
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableSpring;

  /// <summary>
  /// Spring stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float hertz;

  /// <summary>
  /// Spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float dampingRatio;

  /// <summary>
  /// Enable/disable the joint linear limit
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableLimit;

  /// <summary>
  /// The lower translation limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float lowerTranslation;

  /// <summary>
  /// The upper translation limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float upperTranslation;

  /// <summary>
  /// Enable/disable the joint rotational motor
  /// </summary>
  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool enableMotor;

  /// <summary>
  /// The maximum motor torque, typically in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float maxMotorTorque;

  /// <summary>
  /// The desired motor speed in radians per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float motorSpeed;

  /// <summary>
  /// Used internally to detect a valid definition. DO NOT SET.
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int internalValue;
}

  /// <summary>
  /// The explosion definition is used to configure options for explosions. Explosions
  /// consider shape geometry when computing the impulse.
  /// @ingroup world
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ExplosionDef
{

  /// <summary>
  /// Mask bits to filter shapes
  /// </summary>
  /// <returns>Original C type: uint64_t</returns>
  public ulong maskBits;

  /// <summary>
  /// The center of the explosion in world space
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 position;

  /// <summary>
  /// The radius of the explosion
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float radius;

  /// <summary>
  /// The falloff distance beyond the radius. Impulse is reduced to zero at this distance.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float falloff;

  /// <summary>
  /// Impulse per unit length. This applies an impulse according to the shape perimeter that
  /// is facing the explosion. Explosions only apply to circles, capsules, and polygons. This
  /// may be negative for implosions.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float impulsePerLength;
}

  /// <summary>
  /// A begin touch event is generated when a shape starts to overlap a sensor shape.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SensorBeginTouchEvent
{

  /// <summary>
  /// The id of the sensor shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId sensorShapeId;

  /// <summary>
  /// The id of the shape that began touching the sensor shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId visitorShapeId;

  public b2SensorBeginTouchEvent(in b2ShapeId sensorShapeId, in b2ShapeId visitorShapeId)
  {
    this.sensorShapeId = sensorShapeId;
    this.visitorShapeId = visitorShapeId;
  }

}

  /// <summary>
  /// An end touch event is generated when a shape stops overlapping a sensor shape.
  /// These include things like setting the transform, destroying a body or shape, or changing
  /// a filter. You will also get an end event if the sensor or visitor are destroyed.
  /// Therefore you should always confirm the shape id is valid using b2Shape_IsValid.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SensorEndTouchEvent
{

  /// <summary>
  /// The id of the sensor shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId sensorShapeId;

  /// <summary>
  /// The id of the shape that stopped touching the sensor shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId visitorShapeId;

  public b2SensorEndTouchEvent(in b2ShapeId sensorShapeId, in b2ShapeId visitorShapeId)
  {
    this.sensorShapeId = sensorShapeId;
    this.visitorShapeId = visitorShapeId;
  }

}

  /// <summary>
  /// Sensor events are buffered in the world and are available
  /// as begin/end overlap event arrays after the time step is complete.
  /// Note: these may become invalid if bodies and/or shapes are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SensorEvents
{

  /// <summary>
  /// Array of sensor begin touch events
  /// </summary>
  /// <returns>Original C type: b2SensorBeginTouchEvent*</returns>
  public IntPtr beginEvents;

  /// <summary>
  /// Array of sensor end touch events
  /// </summary>
  /// <returns>Original C type: b2SensorEndTouchEvent*</returns>
  public IntPtr endEvents;

  /// <summary>
  /// The number of begin touch events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int beginCount;

  /// <summary>
  /// The number of end touch events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int endCount;

  public b2SensorEvents(in IntPtr beginEvents, in IntPtr endEvents, in int beginCount, in int endCount)
  {
    this.beginEvents = beginEvents;
    this.endEvents = endEvents;
    this.beginCount = beginCount;
    this.endCount = endCount;
  }

}

  /// <summary>
  /// A begin touch event is generated when two shapes begin touching.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ContactBeginTouchEvent
{

  /// <summary>
  /// Id of the first shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdA;

  /// <summary>
  /// Id of the second shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdB;

  /// <summary>
  /// The transient contact id. This contact maybe destroyed automatically when the world is modified or simulated.
  /// Used b2Contact_IsValid before using this id.
  /// </summary>
  /// <returns>Original C type: b2ContactId</returns>
  public b2ContactId contactId;

  public b2ContactBeginTouchEvent(in b2ShapeId shapeIdA, in b2ShapeId shapeIdB, in b2ContactId contactId)
  {
    this.shapeIdA = shapeIdA;
    this.shapeIdB = shapeIdB;
    this.contactId = contactId;
  }

}

  /// <summary>
  /// An end touch event is generated when two shapes stop touching.
  /// You will get an end event if you do anything that destroys contacts previous to the last
  /// world step. These include things like setting the transform, destroying a body
  /// or shape, or changing a filter or body type.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ContactEndTouchEvent
{

  /// <summary>
  /// Id of the first shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdA;

  /// <summary>
  /// Id of the second shape
  /// @warning this shape may have been destroyed
  /// @see b2Shape_IsValid
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdB;

  /// <summary>
  /// Id of the contact.
  /// @warning this contact may have been destroyed
  /// @see b2Contact_IsValid
  /// </summary>
  /// <returns>Original C type: b2ContactId</returns>
  public b2ContactId contactId;

  public b2ContactEndTouchEvent(in b2ShapeId shapeIdA, in b2ShapeId shapeIdB, in b2ContactId contactId)
  {
    this.shapeIdA = shapeIdA;
    this.shapeIdB = shapeIdB;
    this.contactId = contactId;
  }

}

  /// <summary>
  /// A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.
  /// This may be reported for speculative contacts that have a confirmed impulse.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ContactHitEvent
{

  /// <summary>
  /// Id of the first shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdA;

  /// <summary>
  /// Id of the second shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdB;

  /// <summary>
  /// Point where the shapes hit at the beginning of the time step.
  /// This is a mid-point between the two surfaces. It could be at speculative
  /// point where the two shapes were not touching at the beginning of the time step.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 point;

  /// <summary>
  /// Normal vector pointing from shape A to shape B
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  public Vector2 normal;

  /// <summary>
  /// The speed the shapes are approaching. Always positive. Typically in meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  public float approachSpeed;

  public b2ContactHitEvent(in b2ShapeId shapeIdA, in b2ShapeId shapeIdB, in Vector2 point, in Vector2 normal, in float approachSpeed)
  {
    this.shapeIdA = shapeIdA;
    this.shapeIdB = shapeIdB;
    this.point = point;
    this.normal = normal;
    this.approachSpeed = approachSpeed;
  }

}

  /// <summary>
  /// Contact events are buffered in the Box2D world and are available
  /// as event arrays after the time step is complete.
  /// Note: these may become invalid if bodies and/or shapes are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ContactEvents
{

  /// <summary>
  /// Array of begin touch events
  /// </summary>
  /// <returns>Original C type: b2ContactBeginTouchEvent*</returns>
  public IntPtr beginEvents;

  /// <summary>
  /// Array of end touch events
  /// </summary>
  /// <returns>Original C type: b2ContactEndTouchEvent*</returns>
  public IntPtr endEvents;

  /// <summary>
  /// Array of hit events
  /// </summary>
  /// <returns>Original C type: b2ContactHitEvent*</returns>
  public IntPtr hitEvents;

  /// <summary>
  /// Number of begin touch events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int beginCount;

  /// <summary>
  /// Number of end touch events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int endCount;

  /// <summary>
  /// Number of hit events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int hitCount;

  public b2ContactEvents(in IntPtr beginEvents, in IntPtr endEvents, in IntPtr hitEvents, in int beginCount, in int endCount, in int hitCount)
  {
    this.beginEvents = beginEvents;
    this.endEvents = endEvents;
    this.hitEvents = hitEvents;
    this.beginCount = beginCount;
    this.endCount = endCount;
    this.hitCount = hitCount;
  }

}

  /// <summary>
  /// Body move events triggered when a body moves.
  /// Triggered when a body moves due to simulation. Not reported for bodies moved by the user.
  /// This also has a flag to indicate that the body went to sleep so the application can also
  /// sleep that actor/entity/object associated with the body.
  /// On the other hand if the flag does not indicate the body went to sleep then the application
  /// can treat the actor/entity/object associated with the body as awake.
  /// This is an efficient way for an application to update game object transforms rather than
  /// calling functions such as b2Body_GetTransform() because this data is delivered as a contiguous array
  /// and it is only populated with bodies that have moved.
  /// @note If sleeping is disabled all dynamic and kinematic bodies will trigger move events.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2BodyMoveEvent
{

  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  /// <returns>Original C type: b2Transform</returns>
  public b2Transform transform;

  /// <returns>Original C type: b2BodyId</returns>
  public b2BodyId bodyId;

  /// <returns>Original C type: bool</returns>
  [MarshalAs(UnmanagedType.U1)]
  public bool fellAsleep;

  public b2BodyMoveEvent(in IntPtr /* void* */ userData, in b2Transform transform, in b2BodyId bodyId, in bool fellAsleep)
  {
    this.userData = userData;
    this.transform = transform;
    this.bodyId = bodyId;
    this.fellAsleep = fellAsleep;
  }

}

  /// <summary>
  /// Body events are buffered in the Box2D world and are available
  /// as event arrays after the time step is complete.
  /// Note: this data becomes invalid if bodies are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2BodyEvents
{

  /// <summary>
  /// Array of move events
  /// </summary>
  /// <returns>Original C type: b2BodyMoveEvent*</returns>
  public IntPtr moveEvents;

  /// <summary>
  /// Number of move events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int moveCount;

  public b2BodyEvents(in IntPtr moveEvents, in int moveCount)
  {
    this.moveEvents = moveEvents;
    this.moveCount = moveCount;
  }

}

  /// <summary>
  /// Joint events report joints that are awake and have a force and/or torque exceeding the threshold
  /// The observed forces and torques are not returned for efficiency reasons.
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2JointEvent
{

  /// <summary>
  /// The joint id
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  public b2JointId jointId;

  /// <summary>
  /// The user data from the joint for convenience
  /// </summary>
  /// <returns>Original C type: void*</returns>
  public IntPtr /* void* */ userData;

  public b2JointEvent(in b2JointId jointId, in IntPtr /* void* */ userData)
  {
    this.jointId = jointId;
    this.userData = userData;
  }

}

  /// <summary>
  /// Joint events are buffered in the world and are available
  /// as event arrays after the time step is complete.
  /// Note: this data becomes invalid if joints are destroyed
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2JointEvents
{

  /// <summary>
  /// Array of events
  /// </summary>
  /// <returns>Original C type: b2JointEvent*</returns>
  public IntPtr jointEvents;

  /// <summary>
  /// Number of events
  /// </summary>
  /// <returns>Original C type: int</returns>
  public int count;

  public b2JointEvents(in IntPtr jointEvents, in int count)
  {
    this.jointEvents = jointEvents;
    this.count = count;
  }

}

  /// <summary>
  /// The contact data for two shapes. By convention the manifold normal points
  /// from shape A to shape B.
  /// @see b2Shape_GetContactData() and b2Body_GetContactData()
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2SensorData
{

  /// <summary>
  /// The visiting shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId visitorId;

  /// <summary>
  /// The transform of the body of the visiting shape. This is normally
  /// the current transform of the body. However, for a sensor hit, this is
  /// the transform of the visiting body when it hit.
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  public b2Transform visitTransform;

  public b2SensorData(in b2ShapeId visitorId, in b2Transform visitTransform)
  {
    this.visitorId = visitorId;
    this.visitTransform = visitTransform;
  }

}

  /// <summary>
  /// The contact data for two shapes. By convention the manifold normal points
  /// from shape A to shape B.
  /// @see b2Shape_GetContactData() and b2Body_GetContactData()
  /// </summary>
[StructLayout(LayoutKind.Sequential)]
public partial struct b2ContactData
{

  /// <returns>Original C type: b2ContactId</returns>
  public b2ContactId contactId;

  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdA;

  /// <returns>Original C type: b2ShapeId</returns>
  public b2ShapeId shapeIdB;

  /// <returns>Original C type: b2Manifold</returns>
  public b2Manifold manifold;

  public b2ContactData(in b2ContactId contactId, in b2ShapeId shapeIdA, in b2ShapeId shapeIdB, in b2Manifold manifold)
  {
    this.contactId = contactId;
    this.shapeIdA = shapeIdA;
    this.shapeIdB = shapeIdB;
    this.manifold = manifold;
  }

}

/// <summary>
/// The (more or less) full Box2D v3.x API as PInvoke functions. (functions marked with C macro 'B2_API' in original sources)
/// </summary>
public static partial class B2Api
    {
#if DEBUG
        private const string Box2DLibrary = "box2dd.dll";
#else
        private const string Box2DLibrary = "box2d.dll";
#endif

  /// <returns>Original C type: int</returns>
public const int B2_ZERO_INIT = 0;

  /// <summary>
  /// Simple djb2 hash function for determinism testing
  /// </summary>
  /// <returns>Original C type: int</returns>
public const int B2_HASH_INIT = 5381;

  /// <summary>
  /// The maximum number of vertices on a convex polygon. Changing this affects performance even if you
  /// don't use more vertices.
  /// </summary>
  /// <returns>Original C type: int</returns>
public const int B2_MAX_POLYGON_VERTICES = 8;

  /// <summary>
  /// https://en.wikipedia.org/wiki/Pi
  /// </summary>
  /// <returns>Original C type: float</returns>
public const float B2_PI = 3.14159265359f;

  /// <returns>Original C type: int</returns>
public const int B2_DEFAULT_CATEGORY_BITS = 1;

  /// <summary>
  /// This allows the user to override the allocation functions. These should be
  /// set during application startup.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="allocFcn">(Original C type: b2AllocFcn*)</param>
  /// <param name="freeFcn">(Original C type: b2FreeFcn*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SetAllocator(IntPtr allocFcn, IntPtr freeFcn);

  /// <summary>
  /// This allows the user to override the allocation functions. These should be
  /// set during application startup.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="allocFcn">(Original C type: b2AllocFcn*)</param>
  /// <param name="freeFcn">(Original C type: b2FreeFcn*)</param>
public static void b2SetAllocator(b2AllocFcn allocFcn, b2FreeFcn freeFcn)
{
    b2SetAllocator(Marshal.GetFunctionPointerForDelegate(allocFcn), Marshal.GetFunctionPointerForDelegate(freeFcn));
}

  /// <summary>
  /// @return the total bytes allocated by Box2D
  /// </summary>
  /// <returns>Original C type: int</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2GetByteCount();

  /// <summary>
  /// Override the default assert callback
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="assertFcn">a non-null assert callback
  /// (Original C type: b2AssertFcn*)</param>
  /// <param name="assertFcn">a non-null assert callback
  /// (Original C type: b2AssertFcn*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SetAssertFcn(IntPtr assertFcn);

  /// <summary>
  /// Override the default assert callback
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="assertFcn">a non-null assert callback
  /// (Original C type: b2AssertFcn*)</param>
  /// <param name="assertFcn">a non-null assert callback
  /// (Original C type: b2AssertFcn*)</param>
public static void b2SetAssertFcn(b2AssertFcn assertFcn)
{
    b2SetAssertFcn(Marshal.GetFunctionPointerForDelegate(assertFcn));
}

  /// <summary>
  /// Get the current version of Box2D
  /// </summary>
  /// <returns>Original C type: b2Version</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Version b2GetVersion();

  /// <returns>Original C type: int</returns>
  /// <param name="condition">(Original C type: const char*)</param>
  /// <param name="fileName">(Original C type: const char*)</param>
  /// <param name="lineNumber">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2InternalAssertFcn(string condition, string fileName, int lineNumber);

  /// <summary>
  /// Get the absolute number of system ticks. The value is platform specific.
  /// </summary>
  /// <returns>Original C type: uint64_t</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern ulong b2GetTicks();

  /// <summary>
  /// Get the milliseconds passed from an initial tick value.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="ticks">(Original C type: uint64_t)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2GetMilliseconds(ulong ticks);

  /// <summary>
  /// Get the milliseconds passed from an initial tick value. Resets the passed in
  /// value to the current tick value.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="ticks">(Original C type: uint64_t*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2GetMillisecondsAndReset(ref ulong ticks);

  /// <summary>
  /// Yield to be used in a busy loop.
  /// </summary>
  /// <returns>Original C type: void</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Yield();

  /// <returns>Original C type: uint32_t</returns>
  /// <param name="hash">(Original C type: uint32_t)</param>
  /// <param name="data">(Original C type: const uint8_t*)</param>
  /// <param name="count">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern uint b2Hash(uint hash, IntPtr /* uint8_t* */ data, int count);

  /// <summary>
  /// Create a world for rigid body simulation. A world contains bodies, shapes, and constraints. You make create
  /// up to 128 worlds. Each world is completely independent and may be simulated in parallel.
  /// @return the world id.
  /// </summary>
  /// <returns>Original C type: b2WorldId</returns>
  /// <param name="def">(Original C type: const b2WorldDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2CreateWorld(in b2WorldDef def);

  /// <summary>
  /// Destroy a world
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyWorld(b2WorldId worldId);

  /// <summary>
  /// World id validation. Provides validation for up to 64K allocations.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="id">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsValid(b2WorldId id);

  /// <summary>
  /// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">The world to simulate
  /// (Original C type: b2WorldId)</param>
  /// <param name="timeStep">The amount of time to simulate, this should be a fixed number. Usually 1/60.
  /// (Original C type: float)</param>
  /// <param name="subStepCount">The number of sub-steps, increasing the sub-step count can increase accuracy. Usually 4.
  /// (Original C type: int)</param>
  /// <param name="worldId">The world to simulate
  /// (Original C type: b2WorldId)</param>
  /// <param name="timeStep">The amount of time to simulate, this should be a fixed number. Usually 1/60.
  /// (Original C type: float)</param>
  /// <param name="subStepCount">The number of sub-steps, increasing the sub-step count can increase accuracy. Usually 4.
  /// (Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_Step(b2WorldId worldId, float timeStep, int subStepCount);

  /// <summary>
  /// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
  /// <returns>Original C type: b2BodyEvents</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyEvents b2World_GetBodyEvents(b2WorldId worldId);

  /// <summary>
  /// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
  /// <returns>Original C type: b2SensorEvents</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2SensorEvents b2World_GetSensorEvents(b2WorldId worldId);

  /// <summary>
  /// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
  /// <returns>Original C type: b2ContactEvents</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ContactEvents b2World_GetContactEvents(b2WorldId worldId);

  /// <summary>
  /// Get the joint events for the current time step. The event data is transient. Do not store a reference to this data.
  /// </summary>
  /// <returns>Original C type: b2JointEvents</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointEvents b2World_GetJointEvents(b2WorldId worldId);

  /// <summary>
  /// Overlap test for all shapes that *potentially* overlap the provided AABB
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="aabb">(Original C type: b2AABB)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2OverlapResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapAABB(b2WorldId worldId, b2AABB aabb, b2QueryFilter filter, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Overlap test for all shapes that *potentially* overlap the provided AABB
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="aabb">(Original C type: b2AABB)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2OverlapResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
public static b2TreeStats b2World_OverlapAABB(b2WorldId worldId, b2AABB aabb, b2QueryFilter filter, b2OverlapResultFcn fcn, IntPtr /* void* */ context)
{
    return b2World_OverlapAABB(worldId, aabb, filter, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Overlap test for all shapes that overlap the provided shape proxy.
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="proxy">(Original C type: const b2ShapeProxy*)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2OverlapResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_OverlapShape(b2WorldId worldId, in b2ShapeProxy proxy, b2QueryFilter filter, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Overlap test for all shapes that overlap the provided shape proxy.
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="proxy">(Original C type: const b2ShapeProxy*)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2OverlapResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
public static b2TreeStats b2World_OverlapShape(b2WorldId worldId, in b2ShapeProxy proxy, b2QueryFilter filter, b2OverlapResultFcn fcn, IntPtr /* void* */ context)
{
    return b2World_OverlapShape(worldId, proxy, filter, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Cast a ray into the world to collect shapes in the path of the ray.
  /// Your callback function controls whether you get the closest point, any point, or n-points.
  /// @note The callback function may receive shapes in any order
  /// @return traversal performance counters
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">The world to cast the ray against
  /// (Original C type: b2WorldId)</param>
  /// <param name="origin">The start point of the ray
  /// (Original C type: b2Vec2)</param>
  /// <param name="translation">The translation of the ray from the start point to the end point
  /// (Original C type: b2Vec2)</param>
  /// <param name="filter">Contains bit flags to filter unwanted shapes from the results
  /// (Original C type: b2QueryFilter)</param>
  /// <param name="fcn">A user implemented callback function
  /// (Original C type: b2CastResultFcn*)</param>
  /// <param name="context">A user context that is passed along to the callback function
  /// (Original C type: void*)</param>
  /// <param name="worldId">The world to cast the ray against
  /// (Original C type: b2WorldId)</param>
  /// <param name="origin">The start point of the ray
  /// (Original C type: b2Vec2)</param>
  /// <param name="translation">The translation of the ray from the start point to the end point
  /// (Original C type: b2Vec2)</param>
  /// <param name="filter">Contains bit flags to filter unwanted shapes from the results
  /// (Original C type: b2QueryFilter)</param>
  /// <param name="fcn">A user implemented callback function
  /// (Original C type: b2CastResultFcn*)</param>
  /// <param name="context">A user context that is passed along to the callback function
  /// (Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_CastRay(b2WorldId worldId, Vector2 origin, Vector2 translation, b2QueryFilter filter, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Cast a ray into the world to collect shapes in the path of the ray.
  /// Your callback function controls whether you get the closest point, any point, or n-points.
  /// @note The callback function may receive shapes in any order
  /// @return traversal performance counters
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">The world to cast the ray against
  /// (Original C type: b2WorldId)</param>
  /// <param name="origin">The start point of the ray
  /// (Original C type: b2Vec2)</param>
  /// <param name="translation">The translation of the ray from the start point to the end point
  /// (Original C type: b2Vec2)</param>
  /// <param name="filter">Contains bit flags to filter unwanted shapes from the results
  /// (Original C type: b2QueryFilter)</param>
  /// <param name="fcn">A user implemented callback function
  /// (Original C type: b2CastResultFcn*)</param>
  /// <param name="context">A user context that is passed along to the callback function
  /// (Original C type: void*)</param>
  /// <param name="worldId">The world to cast the ray against
  /// (Original C type: b2WorldId)</param>
  /// <param name="origin">The start point of the ray
  /// (Original C type: b2Vec2)</param>
  /// <param name="translation">The translation of the ray from the start point to the end point
  /// (Original C type: b2Vec2)</param>
  /// <param name="filter">Contains bit flags to filter unwanted shapes from the results
  /// (Original C type: b2QueryFilter)</param>
  /// <param name="fcn">A user implemented callback function
  /// (Original C type: b2CastResultFcn*)</param>
  /// <param name="context">A user context that is passed along to the callback function
  /// (Original C type: void*)</param>
public static b2TreeStats b2World_CastRay(b2WorldId worldId, Vector2 origin, Vector2 translation, b2QueryFilter filter, b2CastResultFcn fcn, IntPtr /* void* */ context)
{
    return b2World_CastRay(worldId, origin, translation, filter, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Cast a ray into the world to collect the closest hit. This is a convenience function. Ignores initial overlap.
  /// This is less general than b2World_CastRay() and does not allow for custom filtering.
  /// </summary>
  /// <returns>Original C type: b2RayResult</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="origin">(Original C type: b2Vec2)</param>
  /// <param name="translation">(Original C type: b2Vec2)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2RayResult b2World_CastRayClosest(b2WorldId worldId, Vector2 origin, Vector2 translation, b2QueryFilter filter);

  /// <summary>
  /// Cast a shape through the world. Similar to a cast ray except that a shape is cast instead of a point.
  /// @see b2World_CastRay
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="proxy">(Original C type: const b2ShapeProxy*)</param>
  /// <param name="translation">(Original C type: b2Vec2)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2CastResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TreeStats b2World_CastShape(b2WorldId worldId, in b2ShapeProxy proxy, Vector2 translation, b2QueryFilter filter, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Cast a shape through the world. Similar to a cast ray except that a shape is cast instead of a point.
  /// @see b2World_CastRay
  /// </summary>
  /// <returns>Original C type: b2TreeStats</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="proxy">(Original C type: const b2ShapeProxy*)</param>
  /// <param name="translation">(Original C type: b2Vec2)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2CastResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
public static b2TreeStats b2World_CastShape(b2WorldId worldId, in b2ShapeProxy proxy, Vector2 translation, b2QueryFilter filter, b2CastResultFcn fcn, IntPtr /* void* */ context)
{
    return b2World_CastShape(worldId, proxy, translation, filter, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Cast a capsule mover through the world. This is a special shape cast that handles sliding along other shapes while reducing
  /// clipping.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="mover">(Original C type: const b2Capsule*)</param>
  /// <param name="translation">(Original C type: b2Vec2)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_CastMover(b2WorldId worldId, in b2Capsule mover, Vector2 translation, b2QueryFilter filter);

  /// <summary>
  /// Collide a capsule mover with the world, gathering collision planes that can be fed to b2SolvePlanes. Useful for
  /// kinematic character movement.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="mover">(Original C type: const b2Capsule*)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2PlaneResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_CollideMover(b2WorldId worldId, in b2Capsule mover, b2QueryFilter filter, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Collide a capsule mover with the world, gathering collision planes that can be fed to b2SolvePlanes. Useful for
  /// kinematic character movement.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="mover">(Original C type: const b2Capsule*)</param>
  /// <param name="filter">(Original C type: b2QueryFilter)</param>
  /// <param name="fcn">(Original C type: b2PlaneResultFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
public static void b2World_CollideMover(b2WorldId worldId, in b2Capsule mover, b2QueryFilter filter, b2PlaneResultFcn fcn, IntPtr /* void* */ context)
{
    b2World_CollideMover(worldId, mover, filter, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Enable/disable sleep. If your application does not need sleeping, you can gain some performance
  /// by disabling sleep completely at the world level.
  /// @see b2WorldDef
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableSleeping(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is body sleeping enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsSleepingEnabled(b2WorldId worldId);

  /// <summary>
  /// Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous
  /// collision enabled to prevent fast moving objects from going through static objects. The performance gain from
  /// disabling continuous collision is minor.
  /// @see b2WorldDef
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableContinuous(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is continuous collision enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsContinuousEnabled(b2WorldId worldId);

  /// <summary>
  /// Adjust the restitution threshold. It is recommended not to make this value very small
  /// because it will prevent bodies from sleeping. Usually in meters per second.
  /// @see b2WorldDef
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="value">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetRestitutionThreshold(b2WorldId worldId, float value);

  /// <summary>
  /// Get the the restitution speed threshold. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_GetRestitutionThreshold(b2WorldId worldId);

  /// <summary>
  /// Adjust the hit event threshold. This controls the collision speed needed to generate a b2ContactHitEvent.
  /// Usually in meters per second.
  /// @see b2WorldDef::hitEventThreshold
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="value">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetHitEventThreshold(b2WorldId worldId, float value);

  /// <summary>
  /// Get the the hit event speed threshold. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_GetHitEventThreshold(b2WorldId worldId);

  /// <summary>
  /// Register the custom filter callback. This is optional.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="fcn">(Original C type: b2CustomFilterFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetCustomFilterCallback(b2WorldId worldId, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Register the custom filter callback. This is optional.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="fcn">(Original C type: b2CustomFilterFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
public static void b2World_SetCustomFilterCallback(b2WorldId worldId, b2CustomFilterFcn fcn, IntPtr /* void* */ context)
{
    b2World_SetCustomFilterCallback(worldId, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Register the pre-solve callback. This is optional.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="fcn">(Original C type: b2PreSolveFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetPreSolveCallback(b2WorldId worldId, IntPtr fcn, IntPtr /* void* */ context);

  /// <summary>
  /// Register the pre-solve callback. This is optional.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="fcn">(Original C type: b2PreSolveFcn*)</param>
  /// <param name="context">(Original C type: void*)</param>
public static void b2World_SetPreSolveCallback(b2WorldId worldId, b2PreSolveFcn fcn, IntPtr /* void* */ context)
{
    b2World_SetPreSolveCallback(worldId, Marshal.GetFunctionPointerForDelegate(fcn), context);
}

  /// <summary>
  /// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this
  /// is left as a decision for the application. Usually in m/s^2.
  /// @see b2WorldDef
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="gravity">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetGravity(b2WorldId worldId, Vector2 gravity);

  /// <summary>
  /// Get the gravity vector
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2World_GetGravity(b2WorldId worldId);

  /// <summary>
  /// Apply a radial explosion
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">The world id
  /// (Original C type: b2WorldId)</param>
  /// <param name="explosionDef">The explosion definition
  /// (Original C type: const b2ExplosionDef*)</param>
  /// <param name="worldId">The world id
  /// (Original C type: b2WorldId)</param>
  /// <param name="explosionDef">The explosion definition
  /// (Original C type: const b2ExplosionDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_Explode(b2WorldId worldId, in b2ExplosionDef explosionDef);

  /// <summary>
  /// Adjust contact tuning parameters
  /// @note Advanced feature
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">The world id
  /// (Original C type: b2WorldId)</param>
  /// <param name="hertz">The contact stiffness (cycles per second)
  /// (Original C type: float)</param>
  /// <param name="dampingRatio">The contact bounciness with 1 being critical damping (non-dimensional)
  /// (Original C type: float)</param>
  /// <param name="pushSpeed">The maximum contact constraint push out speed (meters per second)
  /// (Original C type: float)</param>
  /// <param name="worldId">The world id
  /// (Original C type: b2WorldId)</param>
  /// <param name="hertz">The contact stiffness (cycles per second)
  /// (Original C type: float)</param>
  /// <param name="dampingRatio">The contact bounciness with 1 being critical damping (non-dimensional)
  /// (Original C type: float)</param>
  /// <param name="pushSpeed">The maximum contact constraint push out speed (meters per second)
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetContactTuning(b2WorldId worldId, float hertz, float dampingRatio, float pushSpeed);

  /// <summary>
  /// Set the maximum linear speed. Usually in m/s.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="maximumLinearSpeed">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetMaximumLinearSpeed(b2WorldId worldId, float maximumLinearSpeed);

  /// <summary>
  /// Get the maximum linear speed. Usually in m/s.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2World_GetMaximumLinearSpeed(b2WorldId worldId);

  /// <summary>
  /// Enable/disable constraint warm starting. Advanced feature for testing. Disabling
  /// warm starting greatly reduces stability and provides no performance gain.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableWarmStarting(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is constraint warm starting enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2World_IsWarmStartingEnabled(b2WorldId worldId);

  /// <summary>
  /// Get the number of awake bodies.
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2World_GetAwakeBodyCount(b2WorldId worldId);

  /// <summary>
  /// Get the current world performance profile
  /// </summary>
  /// <returns>Original C type: b2Profile</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Profile b2World_GetProfile(b2WorldId worldId);

  /// <summary>
  /// Get world counters and sizes
  /// </summary>
  /// <returns>Original C type: b2Counters</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Counters b2World_GetCounters(b2WorldId worldId);

  /// <summary>
  /// Set the user data pointer.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="userData">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetUserData(b2WorldId worldId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data pointer.
  /// </summary>
  /// <returns>Original C type: void*</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2World_GetUserData(b2WorldId worldId);

  /// <summary>
  /// Set the friction callback. Passing NULL resets to default.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="callback">(Original C type: b2FrictionCallback*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetFrictionCallback(b2WorldId worldId, IntPtr callback);

  /// <summary>
  /// Set the friction callback. Passing NULL resets to default.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="callback">(Original C type: b2FrictionCallback*)</param>
public static void b2World_SetFrictionCallback(b2WorldId worldId, b2FrictionCallback callback)
{
    b2World_SetFrictionCallback(worldId, Marshal.GetFunctionPointerForDelegate(callback));
}

  /// <summary>
  /// Set the restitution callback. Passing NULL resets to default.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="callback">(Original C type: b2RestitutionCallback*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_SetRestitutionCallback(b2WorldId worldId, IntPtr callback);

  /// <summary>
  /// Set the restitution callback. Passing NULL resets to default.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="callback">(Original C type: b2RestitutionCallback*)</param>
public static void b2World_SetRestitutionCallback(b2WorldId worldId, b2RestitutionCallback callback)
{
    b2World_SetRestitutionCallback(worldId, Marshal.GetFunctionPointerForDelegate(callback));
}

  /// <summary>
  /// Dump memory stats to box2d_memory.txt
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_DumpMemoryStats(b2WorldId worldId);

  /// <summary>
  /// This is for internal testing
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_RebuildStaticTree(b2WorldId worldId);

  /// <summary>
  /// This is for internal testing
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2World_EnableSpeculative(b2WorldId worldId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Create a rigid body given a definition. No reference to the definition is retained. So you can create the definition
  /// on the stack and pass it as a pointer.
  /// @code{.c}
  /// b2BodyDef bodyDef = b2DefaultBodyDef();
  /// b2BodyId myBodyId = b2CreateBody(myWorldId, &bodyDef);
  /// @endcode
  /// @warning This function is locked during callbacks.
  /// </summary>
  /// <returns>Original C type: b2BodyId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2BodyDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2CreateBody(b2WorldId worldId, in b2BodyDef def);

  /// <summary>
  /// Destroy a rigid body given an id. This destroys all shapes and joints attached to the body.
  /// Do not keep references to the associated shapes and joints.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyBody(b2BodyId bodyId);

  /// <summary>
  /// Body identifier validation. Can be used to detect orphaned ids. Provides validation for up to 64K allocations.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="id">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsValid(b2BodyId id);

  /// <summary>
  /// Get the body type: static, kinematic, or dynamic
  /// </summary>
  /// <returns>Original C type: b2BodyType</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyType b2Body_GetType(b2BodyId bodyId);

  /// <summary>
  /// Change the body type. This is an expensive operation. This automatically updates the mass
  /// properties regardless of the automatic mass setting.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="type">(Original C type: b2BodyType)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetType(b2BodyId bodyId, b2BodyType type);

  /// <summary>
  /// Set the body name. Up to 31 characters excluding 0 termination.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="name">(Original C type: const char*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetName(b2BodyId bodyId, string name);

  /// <summary>
  /// Set the user data for a body
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="userData">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetUserData(b2BodyId bodyId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data stored in a body
  /// </summary>
  /// <returns>Original C type: void*</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2Body_GetUserData(b2BodyId bodyId);

  /// <summary>
  /// Get the world position of a body. This is the location of the body origin.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetPosition(b2BodyId bodyId);

  /// <summary>
  /// Get the world rotation of a body as a cosine/sine pair (complex number)
  /// </summary>
  /// <returns>Original C type: b2Rot</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Rot b2Body_GetRotation(b2BodyId bodyId);

  /// <summary>
  /// Get the world transform of a body.
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Transform b2Body_GetTransform(b2BodyId bodyId);

  /// <summary>
  /// Set the world transform of a body. This acts as a teleport and is fairly expensive.
  /// @note Generally you should create a body with then intended transform.
  /// @see b2BodyDef::position and b2BodyDef::rotation
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="position">(Original C type: b2Vec2)</param>
  /// <param name="rotation">(Original C type: b2Rot)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetTransform(b2BodyId bodyId, Vector2 position, b2Rot rotation);

  /// <summary>
  /// Get a local point on a body given a world point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="worldPoint">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalPoint(b2BodyId bodyId, Vector2 worldPoint);

  /// <summary>
  /// Get a world point on a body given a local point
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="localPoint">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldPoint(b2BodyId bodyId, Vector2 localPoint);

  /// <summary>
  /// Get a local vector on a body given a world vector
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="worldVector">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalVector(b2BodyId bodyId, Vector2 worldVector);

  /// <summary>
  /// Get a world vector on a body given a local vector
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="localVector">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldVector(b2BodyId bodyId, Vector2 localVector);

  /// <summary>
  /// Get the linear velocity of a body's center of mass. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLinearVelocity(b2BodyId bodyId);

  /// <summary>
  /// Get the angular velocity of a body in radians per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetAngularVelocity(b2BodyId bodyId);

  /// <summary>
  /// Set the linear velocity of a body. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="linearVelocity">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetLinearVelocity(b2BodyId bodyId, Vector2 linearVelocity);

  /// <summary>
  /// Set the angular velocity of a body in radians per second
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="angularVelocity">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetAngularVelocity(b2BodyId bodyId, float angularVelocity);

  /// <summary>
  /// Set the velocity to reach the given transform after a given time step.
  /// The result will be close but maybe not exact. This is meant for kinematic bodies.
  /// The target is not applied if the velocity would be below the sleep threshold.
  /// This will automatically wake the body if asleep.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="target">(Original C type: b2Transform)</param>
  /// <param name="timeStep">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetTargetTransform(b2BodyId bodyId, b2Transform target, float timeStep);

  /// <summary>
  /// Get the linear velocity of a local point attached to a body. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="localPoint">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalPointVelocity(b2BodyId bodyId, Vector2 localPoint);

  /// <summary>
  /// Get the linear velocity of a world point attached to a body. Usually in meters per second.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="worldPoint">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldPointVelocity(b2BodyId bodyId, Vector2 worldPoint);

  /// <summary>
  /// Apply a force at a world point. If the force is not applied at the center of mass,
  /// it will generate a torque and affect the angular velocity. This optionally wakes up the body.
  /// The force is ignored if the body is not awake.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="force">The world force vector, usually in newtons (N)
  /// (Original C type: b2Vec2)</param>
  /// <param name="point">The world position of the point of application
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">Option to wake up the body
  /// (Original C type: bool)</param>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="force">The world force vector, usually in newtons (N)
  /// (Original C type: b2Vec2)</param>
  /// <param name="point">The world position of the point of application
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">Option to wake up the body
  /// (Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyForce(b2BodyId bodyId, Vector2 force, Vector2 point, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply a force to the center of mass. This optionally wakes up the body.
  /// The force is ignored if the body is not awake.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="force">the world force vector, usually in newtons (N).
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="force">the world force vector, usually in newtons (N).
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyForceToCenter(b2BodyId bodyId, Vector2 force, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply a torque. This affects the angular velocity without affecting the linear velocity.
  /// This optionally wakes the body. The torque is ignored if the body is not awake.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="torque">about the z-axis (out of the screen), usually in N*m.
  /// (Original C type: float)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="torque">about the z-axis (out of the screen), usually in N*m.
  /// (Original C type: float)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyTorque(b2BodyId bodyId, float torque, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply an impulse at a point. This immediately modifies the velocity.
  /// It also modifies the angular velocity if the point of application
  /// is not at the center of mass. This optionally wakes the body.
  /// The impulse is ignored if the body is not awake.
  /// @warning This should be used for one-shot impulses. If you need a steady force,
  /// use a force instead, which will work better with the sub-stepping solver.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="impulse">the world impulse vector, usually in N*s or kg*m/s.
  /// (Original C type: b2Vec2)</param>
  /// <param name="point">the world position of the point of application.
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="impulse">the world impulse vector, usually in N*s or kg*m/s.
  /// (Original C type: b2Vec2)</param>
  /// <param name="point">the world position of the point of application.
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyLinearImpulse(b2BodyId bodyId, Vector2 impulse, Vector2 point, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply an impulse to the center of mass. This immediately modifies the velocity.
  /// The impulse is ignored if the body is not awake. This optionally wakes the body.
  /// @warning This should be used for one-shot impulses. If you need a steady force,
  /// use a force instead, which will work better with the sub-stepping solver.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="impulse">the world impulse vector, usually in N*s or kg*m/s.
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="impulse">the world impulse vector, usually in N*s or kg*m/s.
  /// (Original C type: b2Vec2)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyLinearImpulseToCenter(b2BodyId bodyId, Vector2 impulse, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Apply an angular impulse. The impulse is ignored if the body is not awake.
  /// This optionally wakes the body.
  /// @warning This should be used for one-shot impulses. If you need a steady force,
  /// use a force instead, which will work better with the sub-stepping solver.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="impulse">the angular impulse, usually in units of kg*m*m/s
  /// (Original C type: float)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
  /// <param name="bodyId">The body id
  /// (Original C type: b2BodyId)</param>
  /// <param name="impulse">the angular impulse, usually in units of kg*m*m/s
  /// (Original C type: float)</param>
  /// <param name="wake">also wake up the body
  /// (Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyAngularImpulse(b2BodyId bodyId, float impulse, [MarshalAs(UnmanagedType.U1)] bool wake);

  /// <summary>
  /// Get the mass of the body, usually in kilograms
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetMass(b2BodyId bodyId);

  /// <summary>
  /// Get the rotational inertia of the body, usually in kg*m^2
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetRotationalInertia(b2BodyId bodyId);

  /// <summary>
  /// Get the center of mass position of the body in local space
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetLocalCenterOfMass(b2BodyId bodyId);

  /// <summary>
  /// Get the center of mass position of the body in world space
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Body_GetWorldCenterOfMass(b2BodyId bodyId);

  /// <summary>
  /// Override the body's mass properties. Normally this is computed automatically using the
  /// shape geometry and density. This information is lost if a shape is added or removed or if the
  /// body type changes.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="massData">(Original C type: b2MassData)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetMassData(b2BodyId bodyId, b2MassData massData);

  /// <summary>
  /// Get the mass data for a body
  /// </summary>
  /// <returns>Original C type: b2MassData</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2Body_GetMassData(b2BodyId bodyId);

  /// <summary>
  /// This update the mass properties to the sum of the mass properties of the shapes.
  /// This normally does not need to be called unless you called SetMassData to override
  /// the mass and you later want to reset the mass.
  /// You may also use this when automatic mass computation has been disabled.
  /// You should call this regardless of body type.
  /// Note that sensor shapes may have mass.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_ApplyMassFromShapes(b2BodyId bodyId);

  /// <summary>
  /// Adjust the linear damping. Normally this is set in b2BodyDef before creation.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="linearDamping">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetLinearDamping(b2BodyId bodyId, float linearDamping);

  /// <summary>
  /// Get the current linear damping.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetLinearDamping(b2BodyId bodyId);

  /// <summary>
  /// Adjust the angular damping. Normally this is set in b2BodyDef before creation.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="angularDamping">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetAngularDamping(b2BodyId bodyId, float angularDamping);

  /// <summary>
  /// Get the current angular damping.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetAngularDamping(b2BodyId bodyId);

  /// <summary>
  /// Adjust the gravity scale. Normally this is set in b2BodyDef before creation.
  /// @see b2BodyDef::gravityScale
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="gravityScale">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetGravityScale(b2BodyId bodyId, float gravityScale);

  /// <summary>
  /// Get the current gravity scale
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetGravityScale(b2BodyId bodyId);

  /// <summary>
  /// @return true if this body is awake
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsAwake(b2BodyId bodyId);

  /// <summary>
  /// Wake a body from sleep. This wakes the entire island the body is touching.
  /// @warning Putting a body to sleep will put the entire island of bodies touching this body to sleep,
  /// which can be expensive and possibly unintuitive.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="awake">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetAwake(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool awake);

  /// <summary>
  /// Enable or disable sleeping for this body. If sleeping is disabled the body will wake.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="enableSleep">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_EnableSleep(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool enableSleep);

  /// <summary>
  /// Returns true if sleeping is enabled for this body
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsSleepEnabled(b2BodyId bodyId);

  /// <summary>
  /// Set the sleep threshold, usually in meters per second
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="sleepThreshold">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetSleepThreshold(b2BodyId bodyId, float sleepThreshold);

  /// <summary>
  /// Get the sleep threshold, usually in meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Body_GetSleepThreshold(b2BodyId bodyId);

  /// <summary>
  /// Returns true if this body is enabled
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsEnabled(b2BodyId bodyId);

  /// <summary>
  /// Disable a body by removing it completely from the simulation. This is expensive.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_Disable(b2BodyId bodyId);

  /// <summary>
  /// Enable a body by adding it to the simulation. This is expensive.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_Enable(b2BodyId bodyId);

  /// <summary>
  /// Set this body to have fixed rotation. This causes the mass to be reset in all cases.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="locks">(Original C type: b2MotionLocks)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetMotionLocks(b2BodyId bodyId, b2MotionLocks locks);

  /// <summary>
  /// Does this body have fixed rotation?
  /// </summary>
  /// <returns>Original C type: b2MotionLocks</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MotionLocks b2Body_GetMotionLocks(b2BodyId bodyId);

  /// <summary>
  /// Set this body to be a bullet. A bullet does continuous collision detection
  /// against dynamic bodies (but not other bullets).
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_SetBullet(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Is this body a bullet?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Body_IsBullet(b2BodyId bodyId);

  /// <summary>
  /// Enable/disable contact events on all shapes.
  /// @see b2ShapeDef::enableContactEvents
  /// @warning changing this at runtime may cause mismatched begin/end touch events
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_EnableContactEvents(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Enable/disable hit events on all shapes
  /// @see b2ShapeDef::enableHitEvents
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Body_EnableHitEvents(b2BodyId bodyId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Get the world that owns this body
  /// </summary>
  /// <returns>Original C type: b2WorldId</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Body_GetWorld(b2BodyId bodyId);

  /// <summary>
  /// Get the number of shapes on this body
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetShapeCount(b2BodyId bodyId);

  /// <summary>
  /// Get the shape ids for all shapes on this body, up to the provided capacity.
  /// @returns the number of shape ids stored in the user array
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="shapeArray">(Original C type: b2ShapeId*)</param>
  /// <param name="capacity">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetShapes(b2BodyId bodyId, b2ShapeId[] shapeArray, int capacity);

  /// <summary>
  /// Get the number of joints on this body
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetJointCount(b2BodyId bodyId);

  /// <summary>
  /// Get the joint ids for all joints on this body, up to the provided capacity
  /// @returns the number of joint ids stored in the user array
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="jointArray">(Original C type: b2JointId*)</param>
  /// <param name="capacity">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetJoints(b2BodyId bodyId, b2JointId[] jointArray, int capacity);

  /// <summary>
  /// Get the maximum capacity required for retrieving all the touching contacts on a body
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetContactCapacity(b2BodyId bodyId);

  /// <summary>
  /// Get the touching contact data for a body.
  /// @note Box2D uses speculative collision so some contact points may be separated.
  /// @returns the number of elements filled in the provided array
  /// @warning do not ignore the return value, it specifies the valid number of elements
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="contactData">(Original C type: b2ContactData*)</param>
  /// <param name="capacity">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Body_GetContactData(b2BodyId bodyId, b2ContactData[] contactData, int capacity);

  /// <summary>
  /// Get the current world AABB that contains all the attached shapes. Note that this may not encompass the body origin.
  /// If there are no shapes attached then the returned AABB is empty and centered on the body origin.
  /// </summary>
  /// <returns>Original C type: b2AABB</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2Body_ComputeAABB(b2BodyId bodyId);

  /// <summary>
  /// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="def">(Original C type: const b2ShapeDef*)</param>
  /// <param name="circle">(Original C type: const b2Circle*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreateCircleShape(b2BodyId bodyId, in b2ShapeDef def, in b2Circle circle);

  /// <summary>
  /// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="def">(Original C type: const b2ShapeDef*)</param>
  /// <param name="segment">(Original C type: const b2Segment*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreateSegmentShape(b2BodyId bodyId, in b2ShapeDef def, in b2Segment segment);

  /// <summary>
  /// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="def">(Original C type: const b2ShapeDef*)</param>
  /// <param name="capsule">(Original C type: const b2Capsule*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreateCapsuleShape(b2BodyId bodyId, in b2ShapeDef def, in b2Capsule capsule);

  /// <summary>
  /// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.
  /// Contacts are not created until the next time step.
  /// @return the shape id for accessing the shape
  /// </summary>
  /// <returns>Original C type: b2ShapeId</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="def">(Original C type: const b2ShapeDef*)</param>
  /// <param name="polygon">(Original C type: const b2Polygon*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeId b2CreatePolygonShape(b2BodyId bodyId, in b2ShapeDef def, in b2Polygon polygon);

  /// <summary>
  /// Destroy a shape. You may defer the body mass update which can improve performance if several shapes on a
  /// body are destroyed at once.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="updateBodyMass">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyShape(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool updateBodyMass);

  /// <summary>
  /// Shape identifier validation. Provides validation for up to 64K allocations.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="id">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_IsValid(b2ShapeId id);

  /// <summary>
  /// Get the type of a shape
  /// </summary>
  /// <returns>Original C type: b2ShapeType</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeType b2Shape_GetType(b2ShapeId shapeId);

  /// <summary>
  /// Get the id of the body that a shape is attached to
  /// </summary>
  /// <returns>Original C type: b2BodyId</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2Shape_GetBody(b2ShapeId shapeId);

  /// <summary>
  /// Get the world that owns this shape
  /// </summary>
  /// <returns>Original C type: b2WorldId</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Shape_GetWorld(b2ShapeId shapeId);

  /// <summary>
  /// Returns true if the shape is a sensor. It is not possible to change a shape
  /// from sensor to solid dynamically because this breaks the contract for
  /// sensor events.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_IsSensor(b2ShapeId shapeId);

  /// <summary>
  /// Set the user data for a shape
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="userData">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetUserData(b2ShapeId shapeId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data for a shape. This is useful when you get a shape id
  /// from an event or query.
  /// </summary>
  /// <returns>Original C type: void*</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2Shape_GetUserData(b2ShapeId shapeId);

  /// <summary>
  /// Set the mass density of a shape, usually in kg/m^2.
  /// This will optionally update the mass properties on the parent body.
  /// @see b2ShapeDef::density, b2Body_ApplyMassFromShapes
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="density">(Original C type: float)</param>
  /// <param name="updateBodyMass">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetDensity(b2ShapeId shapeId, float density, [MarshalAs(UnmanagedType.U1)] bool updateBodyMass);

  /// <summary>
  /// Get the density of a shape, usually in kg/m^2
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Shape_GetDensity(b2ShapeId shapeId);

  /// <summary>
  /// Set the friction on a shape
  /// @see b2ShapeDef::friction
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="friction">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetFriction(b2ShapeId shapeId, float friction);

  /// <summary>
  /// Get the friction of a shape
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Shape_GetFriction(b2ShapeId shapeId);

  /// <summary>
  /// Set the shape restitution (bounciness)
  /// @see b2ShapeDef::restitution
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="restitution">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetRestitution(b2ShapeId shapeId, float restitution);

  /// <summary>
  /// Get the shape restitution
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Shape_GetRestitution(b2ShapeId shapeId);

  /// <summary>
  /// Set the shape material identifier
  /// @see b2ShapeDef::material
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="material">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetMaterial(b2ShapeId shapeId, int material);

  /// <summary>
  /// Get the shape material identifier
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetMaterial(b2ShapeId shapeId);

  /// <summary>
  /// Set the shape surface material
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="surfaceMaterial">(Original C type: b2SurfaceMaterial)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetSurfaceMaterial(b2ShapeId shapeId, b2SurfaceMaterial surfaceMaterial);

  /// <summary>
  /// Get the shape surface material
  /// </summary>
  /// <returns>Original C type: b2SurfaceMaterial</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2SurfaceMaterial b2Shape_GetSurfaceMaterial(b2ShapeId shapeId);

  /// <summary>
  /// Get the shape filter
  /// </summary>
  /// <returns>Original C type: b2Filter</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Filter b2Shape_GetFilter(b2ShapeId shapeId);

  /// <summary>
  /// Set the current filter. This is almost as expensive as recreating the shape. This may cause
  /// contacts to be immediately destroyed. However contacts are not created until the next world step.
  /// Sensor overlap state is also not updated until the next world step.
  /// @see b2ShapeDef::filter
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="filter">(Original C type: b2Filter)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetFilter(b2ShapeId shapeId, b2Filter filter);

  /// <summary>
  /// Enable sensor events for this shape.
  /// @see b2ShapeDef::enableSensorEvents
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnableSensorEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if sensor events are enabled.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_AreSensorEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
  /// @see b2ShapeDef::enableContactEvents
  /// @warning changing this at run-time may lead to lost begin/end events
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnableContactEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if contact events are enabled
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_AreContactEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
  /// and must be carefully handled due to multithreading. Ignored for sensors.
  /// @see b2PreSolveFcn
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnablePreSolveEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if pre-solve events are enabled
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_ArePreSolveEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Enable contact hit events for this shape. Ignored for sensors.
  /// @see b2WorldDef.hitEventThreshold
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="flag">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_EnableHitEvents(b2ShapeId shapeId, [MarshalAs(UnmanagedType.U1)] bool flag);

  /// <summary>
  /// Returns true if hit events are enabled
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_AreHitEventsEnabled(b2ShapeId shapeId);

  /// <summary>
  /// Test a point for overlap with a shape
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="point">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Shape_TestPoint(b2ShapeId shapeId, Vector2 point);

  /// <summary>
  /// Ray cast a shape directly
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2Shape_RayCast(b2ShapeId shapeId, in b2RayCastInput input);

  /// <summary>
  /// Get a copy of the shape's circle. Asserts the type is correct.
  /// </summary>
  /// <returns>Original C type: b2Circle</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Circle b2Shape_GetCircle(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's line segment. Asserts the type is correct.
  /// </summary>
  /// <returns>Original C type: b2Segment</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Segment b2Shape_GetSegment(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's chain segment. These come from chain shapes.
  /// Asserts the type is correct.
  /// </summary>
  /// <returns>Original C type: b2ChainSegment</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainSegment b2Shape_GetChainSegment(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's capsule. Asserts the type is correct.
  /// </summary>
  /// <returns>Original C type: b2Capsule</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Capsule b2Shape_GetCapsule(b2ShapeId shapeId);

  /// <summary>
  /// Get a copy of the shape's convex polygon. Asserts the type is correct.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2Shape_GetPolygon(b2ShapeId shapeId);

  /// <summary>
  /// Allows you to change a shape to be a circle or update the current circle.
  /// This does not modify the mass properties.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="circle">(Original C type: const b2Circle*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetCircle(b2ShapeId shapeId, in b2Circle circle);

  /// <summary>
  /// Allows you to change a shape to be a capsule or update the current capsule.
  /// This does not modify the mass properties.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="capsule">(Original C type: const b2Capsule*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetCapsule(b2ShapeId shapeId, in b2Capsule capsule);

  /// <summary>
  /// Allows you to change a shape to be a segment or update the current segment.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="segment">(Original C type: const b2Segment*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetSegment(b2ShapeId shapeId, in b2Segment segment);

  /// <summary>
  /// Allows you to change a shape to be a polygon or update the current polygon.
  /// This does not modify the mass properties.
  /// @see b2Body_ApplyMassFromShapes
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="polygon">(Original C type: const b2Polygon*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Shape_SetPolygon(b2ShapeId shapeId, in b2Polygon polygon);

  /// <summary>
  /// Get the parent chain id if the shape type is a chain segment, otherwise
  /// returns b2_nullChainId.
  /// </summary>
  /// <returns>Original C type: b2ChainId</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainId b2Shape_GetParentChain(b2ShapeId shapeId);

  /// <summary>
  /// Get the maximum capacity required for retrieving all the touching contacts on a shape
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetContactCapacity(b2ShapeId shapeId);

  /// <summary>
  /// Get the touching contact data for a shape. The provided shapeId will be either shapeIdA or shapeIdB on the contact data.
  /// @note Box2D uses speculative collision so some contact points may be separated.
  /// @returns the number of elements filled in the provided array
  /// @warning do not ignore the return value, it specifies the valid number of elements
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="contactData">(Original C type: b2ContactData*)</param>
  /// <param name="capacity">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetContactData(b2ShapeId shapeId, b2ContactData[] contactData, int capacity);

  /// <summary>
  /// Get the maximum capacity required for retrieving all the overlapped shapes on a sensor shape.
  /// This returns 0 if the provided shape is not a sensor.
  /// @returns the required capacity to get all the overlaps in b2Shape_GetSensorOverlaps
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="shapeId">the id of a sensor shape
  /// (Original C type: b2ShapeId)</param>
  /// <param name="shapeId">the id of a sensor shape
  /// (Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetSensorCapacity(b2ShapeId shapeId);

  /// <summary>
  /// Get the overlap data for a sensor shape.
  /// @returns the number of elements filled in the provided array
  /// @warning do not ignore the return value, it specifies the valid number of elements
  /// @warning overlaps may contain destroyed shapes so use b2Shape_IsValid to confirm each overlap
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="shapeId">the id of a sensor shape
  /// (Original C type: b2ShapeId)</param>
  /// <param name="sensorData">a user allocated array that is filled with the overlapping shapes (visitors)
  /// (Original C type: b2SensorData*)</param>
  /// <param name="capacity">the capacity of overlappedShapes
  /// (Original C type: int)</param>
  /// <param name="shapeId">the id of a sensor shape
  /// (Original C type: b2ShapeId)</param>
  /// <param name="sensorData">a user allocated array that is filled with the overlapping shapes (visitors)
  /// (Original C type: b2SensorData*)</param>
  /// <param name="capacity">the capacity of overlappedShapes
  /// (Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Shape_GetSensorData(b2ShapeId shapeId, b2SensorData[] sensorData, int capacity);

  /// <summary>
  /// Get the current world AABB
  /// </summary>
  /// <returns>Original C type: b2AABB</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2Shape_GetAABB(b2ShapeId shapeId);

  /// <summary>
  /// Compute the mass data for a shape
  /// </summary>
  /// <returns>Original C type: b2MassData</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2Shape_ComputeMassData(b2ShapeId shapeId);

  /// <summary>
  /// Get the closest point on a shape to a target point. Target and result are in world space.
  /// todo need sample
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="shapeId">(Original C type: b2ShapeId)</param>
  /// <param name="target">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Shape_GetClosestPoint(b2ShapeId shapeId, Vector2 target);

  /// <summary>
  /// Chain Shape
  /// Create a chain shape
  /// @see b2ChainDef for details
  /// </summary>
  /// <returns>Original C type: b2ChainId</returns>
  /// <param name="bodyId">(Original C type: b2BodyId)</param>
  /// <param name="def">(Original C type: const b2ChainDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainId b2CreateChain(b2BodyId bodyId, in b2ChainDef def);

  /// <summary>
  /// Destroy a chain shape
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyChain(b2ChainId chainId);

  /// <summary>
  /// Get the world that owns this chain shape
  /// </summary>
  /// <returns>Original C type: b2WorldId</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Chain_GetWorld(b2ChainId chainId);

  /// <summary>
  /// Get the number of segments on this chain
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Chain_GetSegmentCount(b2ChainId chainId);

  /// <summary>
  /// Fill a user array with chain segment shape ids up to the specified capacity. Returns
  /// the actual number of segments returned.
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
  /// <param name="segmentArray">(Original C type: b2ShapeId*)</param>
  /// <param name="capacity">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Chain_GetSegments(b2ChainId chainId, b2ShapeId[] segmentArray, int capacity);

  /// <summary>
  /// Set the chain friction
  /// @see b2ChainDef::friction
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
  /// <param name="friction">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Chain_SetFriction(b2ChainId chainId, float friction);

  /// <summary>
  /// Get the chain friction
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Chain_GetFriction(b2ChainId chainId);

  /// <summary>
  /// Set the chain restitution (bounciness)
  /// @see b2ChainDef::restitution
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
  /// <param name="restitution">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Chain_SetRestitution(b2ChainId chainId, float restitution);

  /// <summary>
  /// Get the chain restitution
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Chain_GetRestitution(b2ChainId chainId);

  /// <summary>
  /// Set the chain material
  /// @see b2ChainDef::material
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
  /// <param name="material">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Chain_SetMaterial(b2ChainId chainId, int material);

  /// <summary>
  /// Get the chain material
  /// </summary>
  /// <returns>Original C type: int</returns>
  /// <param name="chainId">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern int b2Chain_GetMaterial(b2ChainId chainId);

  /// <summary>
  /// Chain identifier validation. Provides validation for up to 64K allocations.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="id">(Original C type: b2ChainId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Chain_IsValid(b2ChainId id);

  /// <summary>
  /// Destroy a joint
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DestroyJoint(b2JointId jointId);

  /// <summary>
  /// Joint identifier validation. Provides validation for up to 64K allocations.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="id">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Joint_IsValid(b2JointId id);

  /// <summary>
  /// Get the joint type
  /// </summary>
  /// <returns>Original C type: b2JointType</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointType b2Joint_GetType(b2JointId jointId);

  /// <summary>
  /// Get body A id on a joint
  /// </summary>
  /// <returns>Original C type: b2BodyId</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2Joint_GetBodyA(b2JointId jointId);

  /// <summary>
  /// Get body B id on a joint
  /// </summary>
  /// <returns>Original C type: b2BodyId</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyId b2Joint_GetBodyB(b2JointId jointId);

  /// <summary>
  /// Get the world that owns this joint
  /// </summary>
  /// <returns>Original C type: b2WorldId</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldId b2Joint_GetWorld(b2JointId jointId);

  /// <summary>
  /// Set the local frame on bodyA
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="localFrame">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetLocalFrameA(b2JointId jointId, b2Transform localFrame);

  /// <summary>
  /// Get the local frame on bodyA
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Transform b2Joint_GetLocalFrameA(b2JointId jointId);

  /// <summary>
  /// Set the local frame on bodyB
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="localFrame">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetLocalFrameB(b2JointId jointId, b2Transform localFrame);

  /// <summary>
  /// Get the local frame on bodyB
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Transform b2Joint_GetLocalFrameB(b2JointId jointId);

  /// <summary>
  /// Toggle collision between connected bodies
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="shouldCollide">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetCollideConnected(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool shouldCollide);

  /// <summary>
  /// Is collision allowed between connected bodies?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Joint_GetCollideConnected(b2JointId jointId);

  /// <summary>
  /// Set the user data on a joint
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="userData">(Original C type: void*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetUserData(b2JointId jointId, IntPtr /* void* */ userData);

  /// <summary>
  /// Get the user data on a joint
  /// </summary>
  /// <returns>Original C type: void*</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr /* void* */ b2Joint_GetUserData(b2JointId jointId);

  /// <summary>
  /// Wake the bodies connect to this joint
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_WakeBodies(b2JointId jointId);

  /// <summary>
  /// Get the current constraint force for this joint. Usually in Newtons.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2Joint_GetConstraintForce(b2JointId jointId);

  /// <summary>
  /// Get the current constraint torque for this joint. Usually in Newton * meters.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Joint_GetConstraintTorque(b2JointId jointId);

  /// <summary>
  /// Get the current linear separation error for this joint. Does not consider admissible movement. Usually in meters.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Joint_GetLinearSeparation(b2JointId jointId);

  /// <summary>
  /// Get the current angular separation error for this joint. Does not consider admissible movement. Usually in meters.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Joint_GetAngularSeparation(b2JointId jointId);

  /// <summary>
  /// Get the joint constraint tuning. Advanced feature.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float*)</param>
  /// <param name="dampingRatio">(Original C type: float*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_GetConstraintTuning(b2JointId jointId, ref float hertz, ref float dampingRatio);

  /// <summary>
  /// Set the joint constraint tuning. Advanced feature.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">the joint
  /// (Original C type: b2JointId)</param>
  /// <param name="hertz">the stiffness in Hertz (cycles per second)
  /// (Original C type: float)</param>
  /// <param name="dampingRatio">the non-dimensional damping ratio (one for critical damping)
  /// (Original C type: float)</param>
  /// <param name="jointId">the joint
  /// (Original C type: b2JointId)</param>
  /// <param name="hertz">the stiffness in Hertz (cycles per second)
  /// (Original C type: float)</param>
  /// <param name="dampingRatio">the non-dimensional damping ratio (one for critical damping)
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2Joint_SetConstraintTuning(b2JointId jointId, float hertz, float dampingRatio);

  /// <summary>
  /// Create a distance joint
  /// @see b2DistanceJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2DistanceJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateDistanceJoint(b2WorldId worldId, in b2DistanceJointDef def);

  /// <summary>
  /// Set the rest length of a distance joint
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">The id for a distance joint
  /// (Original C type: b2JointId)</param>
  /// <param name="length">The new distance joint length
  /// (Original C type: float)</param>
  /// <param name="jointId">The id for a distance joint
  /// (Original C type: b2JointId)</param>
  /// <param name="length">The new distance joint length
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetLength(b2JointId jointId, float length);

  /// <summary>
  /// Get the rest length of a distance joint
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetLength(b2JointId jointId);

  /// <summary>
  /// Enable/disable the distance joint spring. When disabled the distance joint is rigid.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableSpring">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// Is the distance joint spring enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2DistanceJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the spring stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Set the spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the spring Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Get the spring damping ratio
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Enable joint limit. The limit only works if the joint spring is enabled. Otherwise the joint is rigid
  /// and the limit has no effect.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableLimit">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the distance joint limit enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2DistanceJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Set the minimum and maximum length parameters of a distance joint
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="minLength">(Original C type: float)</param>
  /// <param name="maxLength">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetLengthRange(b2JointId jointId, float minLength, float maxLength);

  /// <summary>
  /// Get the distance joint minimum length
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMinLength(b2JointId jointId);

  /// <summary>
  /// Get the distance joint maximum length
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMaxLength(b2JointId jointId);

  /// <summary>
  /// Get the current length of a distance joint
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetCurrentLength(b2JointId jointId);

  /// <summary>
  /// Enable/disable the distance joint motor
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableMotor">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the distance joint motor enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2DistanceJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the distance joint motor speed, usually in meters per second
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="motorSpeed">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the distance joint motor speed, usually in meters per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Set the distance joint maximum motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="force">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2DistanceJoint_SetMaxMotorForce(b2JointId jointId, float force);

  /// <summary>
  /// Get the distance joint maximum motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMaxMotorForce(b2JointId jointId);

  /// <summary>
  /// Get the distance joint current motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2DistanceJoint_GetMotorForce(b2JointId jointId);

  /// <summary>
  /// Create a motor joint
  /// @see b2MotorJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2MotorJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateMotorJoint(b2WorldId worldId, in b2MotorJointDef def);

  /// <summary>
  /// Set the motor joint maximum force, usually in newtons
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="maxForce">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetMaxForce(b2JointId jointId, float maxForce);

  /// <summary>
  /// Get the motor joint maximum force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetMaxForce(b2JointId jointId);

  /// <summary>
  /// Set the motor joint maximum torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="maxTorque">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetMaxTorque(b2JointId jointId, float maxTorque);

  /// <summary>
  /// Get the motor joint maximum torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetMaxTorque(b2JointId jointId);

  /// <summary>
  /// Set the motor joint correction factor, usually in [0, 1]
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="correctionFactor">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MotorJoint_SetCorrectionFactor(b2JointId jointId, float correctionFactor);

  /// <summary>
  /// Get the motor joint correction factor, usually in [0, 1]
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MotorJoint_GetCorrectionFactor(b2JointId jointId);

  /// <summary>
  /// Create a mouse joint
  /// @see b2MouseJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2MouseJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateMouseJoint(b2WorldId worldId, in b2MouseJointDef def);

  /// <summary>
  /// Set the mouse joint spring stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the mouse joint spring stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MouseJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the mouse joint spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the mouse joint damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MouseJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Set the mouse joint maximum force, usually in newtons
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="maxForce">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2MouseJoint_SetMaxForce(b2JointId jointId, float maxForce);

  /// <summary>
  /// Get the mouse joint maximum force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2MouseJoint_GetMaxForce(b2JointId jointId);

  /// <summary>
  /// Create a filter joint.
  /// @see b2FilterJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2FilterJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateFilterJoint(b2WorldId worldId, in b2FilterJointDef def);

  /// <summary>
  /// Create a prismatic (slider) joint.
  /// @see b2PrismaticJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2PrismaticJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreatePrismaticJoint(b2WorldId worldId, in b2PrismaticJointDef def);

  /// <summary>
  /// Enable/disable the joint spring.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableSpring">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// Is the prismatic joint spring enabled or not?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PrismaticJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint stiffness in Hertz.
  /// This should usually be less than a quarter of the simulation rate. For example, if the simulation
  /// runs at 60Hz then the joint stiffness should be 15Hz or less.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the prismatic joint stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint damping ratio (non-dimensional)
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the prismatic spring damping ratio (non-dimensional)
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint spring target angle, usually in meters
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="translation">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetTargetTranslation(b2JointId jointId, float translation);

  /// <summary>
  /// Get the prismatic joint spring target translation, usually in meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetTargetTranslation(b2JointId jointId);

  /// <summary>
  /// Enable/disable a prismatic joint limit
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableLimit">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the prismatic joint limit enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PrismaticJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Get the prismatic joint lower limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetLowerLimit(b2JointId jointId);

  /// <summary>
  /// Get the prismatic joint upper limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetUpperLimit(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint limits
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="lower">(Original C type: float)</param>
  /// <param name="upper">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetLimits(b2JointId jointId, float lower, float upper);

  /// <summary>
  /// Enable/disable a prismatic joint motor
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableMotor">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the prismatic joint motor enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PrismaticJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint motor speed, usually in meters per second
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="motorSpeed">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the prismatic joint motor speed, usually in meters per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Set the prismatic joint maximum motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="force">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2PrismaticJoint_SetMaxMotorForce(b2JointId jointId, float force);

  /// <summary>
  /// Get the prismatic joint maximum motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetMaxMotorForce(b2JointId jointId);

  /// <summary>
  /// Get the prismatic joint current motor force, usually in newtons
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetMotorForce(b2JointId jointId);

  /// <summary>
  /// Get the current joint translation, usually in meters.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetTranslation(b2JointId jointId);

  /// <summary>
  /// Get the current joint translation speed, usually in meters per second.
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2PrismaticJoint_GetSpeed(b2JointId jointId);

  /// <summary>
  /// Create a revolute joint
  /// @see b2RevoluteJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2RevoluteJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateRevoluteJoint(b2WorldId worldId, in b2RevoluteJointDef def);

  /// <summary>
  /// Enable/disable the revolute joint spring
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableSpring">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// It the revolute angular spring enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2RevoluteJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint spring stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the revolute joint spring stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the revolute joint spring damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint spring target angle, radians
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="angle">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetTargetAngle(b2JointId jointId, float angle);

  /// <summary>
  /// Get the revolute joint spring target angle, radians
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetTargetAngle(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint current angle in radians relative to the reference angle
  /// @see b2RevoluteJointDef::referenceAngle
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetAngle(b2JointId jointId);

  /// <summary>
  /// Enable/disable the revolute joint limit
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableLimit">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the revolute joint limit enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2RevoluteJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint lower limit in radians
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetLowerLimit(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint upper limit in radians
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetUpperLimit(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint limits in radians. It is expected that lower <= upper
  /// and that -0.99 * B2_PI <= lower && upper <= -0.99 * B2_PI.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="lower">(Original C type: float)</param>
  /// <param name="upper">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetLimits(b2JointId jointId, float lower, float upper);

  /// <summary>
  /// Enable/disable a revolute joint motor
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableMotor">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the revolute joint motor enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2RevoluteJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint motor speed in radians per second
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="motorSpeed">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the revolute joint motor speed in radians per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Get the revolute joint current motor torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetMotorTorque(b2JointId jointId);

  /// <summary>
  /// Set the revolute joint maximum motor torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="torque">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2RevoluteJoint_SetMaxMotorTorque(b2JointId jointId, float torque);

  /// <summary>
  /// Get the revolute joint maximum motor torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2RevoluteJoint_GetMaxMotorTorque(b2JointId jointId);

  /// <summary>
  /// Create a weld joint
  /// @see b2WeldJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2WeldJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateWeldJoint(b2WorldId worldId, in b2WeldJointDef def);

  /// <summary>
  /// Set the weld joint linear stiffness in Hertz. 0 is rigid.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetLinearHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the weld joint linear stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetLinearHertz(b2JointId jointId);

  /// <summary>
  /// Set the weld joint linear damping ratio (non-dimensional)
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetLinearDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the weld joint linear damping ratio (non-dimensional)
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetLinearDampingRatio(b2JointId jointId);

  /// <summary>
  /// Set the weld joint angular stiffness in Hertz. 0 is rigid.
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetAngularHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the weld joint angular stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetAngularHertz(b2JointId jointId);

  /// <summary>
  /// Set weld joint angular damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WeldJoint_SetAngularDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the weld joint angular damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WeldJoint_GetAngularDampingRatio(b2JointId jointId);

  /// <summary>
  /// Create a wheel joint
  /// @see b2WheelJointDef for details
  /// </summary>
  /// <returns>Original C type: b2JointId</returns>
  /// <param name="worldId">(Original C type: b2WorldId)</param>
  /// <param name="def">(Original C type: const b2WheelJointDef*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2JointId b2CreateWheelJoint(b2WorldId worldId, in b2WheelJointDef def);

  /// <summary>
  /// Enable/disable the wheel joint spring
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableSpring">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_EnableSpring(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableSpring);

  /// <summary>
  /// Is the wheel joint spring enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2WheelJoint_IsSpringEnabled(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="hertz">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetSpringHertz(b2JointId jointId, float hertz);

  /// <summary>
  /// Get the wheel joint stiffness in Hertz
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetSpringHertz(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="dampingRatio">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetSpringDampingRatio(b2JointId jointId, float dampingRatio);

  /// <summary>
  /// Get the wheel joint damping ratio, non-dimensional
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetSpringDampingRatio(b2JointId jointId);

  /// <summary>
  /// Enable/disable the wheel joint limit
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableLimit">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_EnableLimit(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableLimit);

  /// <summary>
  /// Is the wheel joint limit enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2WheelJoint_IsLimitEnabled(b2JointId jointId);

  /// <summary>
  /// Get the wheel joint lower limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetLowerLimit(b2JointId jointId);

  /// <summary>
  /// Get the wheel joint upper limit
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetUpperLimit(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint limits
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="lower">(Original C type: float)</param>
  /// <param name="upper">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetLimits(b2JointId jointId, float lower, float upper);

  /// <summary>
  /// Enable/disable the wheel joint motor
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="enableMotor">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_EnableMotor(b2JointId jointId, [MarshalAs(UnmanagedType.U1)] bool enableMotor);

  /// <summary>
  /// Is the wheel joint motor enabled?
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2WheelJoint_IsMotorEnabled(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint motor speed in radians per second
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="motorSpeed">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed);

  /// <summary>
  /// Get the wheel joint motor speed in radians per second
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetMotorSpeed(b2JointId jointId);

  /// <summary>
  /// Set the wheel joint maximum motor torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
  /// <param name="torque">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2WheelJoint_SetMaxMotorTorque(b2JointId jointId, float torque);

  /// <summary>
  /// Get the wheel joint maximum motor torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetMaxMotorTorque(b2JointId jointId);

  /// <summary>
  /// Get the wheel joint current motor torque, usually in newton-meters
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="jointId">(Original C type: b2JointId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2WheelJoint_GetMotorTorque(b2JointId jointId);

  /// <summary>
  /// Contact identifier validation. Provides validation for up to 2^32 allocations.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="id">(Original C type: b2ContactId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2Contact_IsValid(b2ContactId id);

  /// <summary>
  /// Get the data for a contact. The manifold may have no points if the contact is not touching.
  /// </summary>
  /// <returns>Original C type: b2ContactData</returns>
  /// <param name="contactId">(Original C type: b2ContactId)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ContactData b2Contact_GetData(b2ContactId contactId);

  /// <summary>
  /// Validate ray cast input data (NaN, etc)
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidRay(in b2RayCastInput input);

  /// <summary>
  /// Make a convex polygon from a convex hull. This will assert if the hull is not valid.
  /// @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="hull">(Original C type: const b2Hull*)</param>
  /// <param name="radius">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakePolygon(in b2Hull hull, float radius);

  /// <summary>
  /// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.
  /// @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="hull">(Original C type: const b2Hull*)</param>
  /// <param name="position">(Original C type: b2Vec2)</param>
  /// <param name="rotation">(Original C type: b2Rot)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetPolygon(in b2Hull hull, Vector2 position, b2Rot rotation);

  /// <summary>
  /// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.
  /// @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="hull">(Original C type: const b2Hull*)</param>
  /// <param name="position">(Original C type: b2Vec2)</param>
  /// <param name="rotation">(Original C type: b2Rot)</param>
  /// <param name="radius">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetRoundedPolygon(in b2Hull hull, Vector2 position, b2Rot rotation, float radius);

  /// <summary>
  /// Make a square polygon, bypassing the need for a convex hull.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="halfWidth">the half-width
  /// (Original C type: float)</param>
  /// <param name="halfWidth">the half-width
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeSquare(float halfWidth);

  /// <summary>
  /// Make a box (rectangle) polygon, bypassing the need for a convex hull.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeBox(float halfWidth, float halfHeight);

  /// <summary>
  /// Make a rounded box, bypassing the need for a convex hull.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="radius">the radius of the rounded extension
  /// (Original C type: float)</param>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="radius">the radius of the rounded extension
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeRoundedBox(float halfWidth, float halfHeight, float radius);

  /// <summary>
  /// Make an offset box, bypassing the need for a convex hull.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="center">the local center of the box
  /// (Original C type: b2Vec2)</param>
  /// <param name="rotation">the local rotation of the box
  /// (Original C type: b2Rot)</param>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="center">the local center of the box
  /// (Original C type: b2Vec2)</param>
  /// <param name="rotation">the local rotation of the box
  /// (Original C type: b2Rot)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetBox(float halfWidth, float halfHeight, Vector2 center, b2Rot rotation);

  /// <summary>
  /// Make an offset rounded box, bypassing the need for a convex hull.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="center">the local center of the box
  /// (Original C type: b2Vec2)</param>
  /// <param name="rotation">the local rotation of the box
  /// (Original C type: b2Rot)</param>
  /// <param name="radius">the radius of the rounded extension
  /// (Original C type: float)</param>
  /// <param name="halfWidth">the half-width (x-axis)
  /// (Original C type: float)</param>
  /// <param name="halfHeight">the half-height (y-axis)
  /// (Original C type: float)</param>
  /// <param name="center">the local center of the box
  /// (Original C type: b2Vec2)</param>
  /// <param name="rotation">the local rotation of the box
  /// (Original C type: b2Rot)</param>
  /// <param name="radius">the radius of the rounded extension
  /// (Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2MakeOffsetRoundedBox(float halfWidth, float halfHeight, Vector2 center, b2Rot rotation, float radius);

  /// <summary>
  /// Transform a polygon. This is useful for transferring a shape from one body to another.
  /// </summary>
  /// <returns>Original C type: b2Polygon</returns>
  /// <param name="transform">(Original C type: b2Transform)</param>
  /// <param name="polygon">(Original C type: const b2Polygon*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Polygon b2TransformPolygon(b2Transform transform, in b2Polygon polygon);

  /// <summary>
  /// Compute mass properties of a circle
  /// </summary>
  /// <returns>Original C type: b2MassData</returns>
  /// <param name="shape">(Original C type: const b2Circle*)</param>
  /// <param name="density">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2ComputeCircleMass(in b2Circle shape, float density);

  /// <summary>
  /// Compute mass properties of a capsule
  /// </summary>
  /// <returns>Original C type: b2MassData</returns>
  /// <param name="shape">(Original C type: const b2Capsule*)</param>
  /// <param name="density">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2ComputeCapsuleMass(in b2Capsule shape, float density);

  /// <summary>
  /// Compute mass properties of a polygon
  /// </summary>
  /// <returns>Original C type: b2MassData</returns>
  /// <param name="shape">(Original C type: const b2Polygon*)</param>
  /// <param name="density">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MassData b2ComputePolygonMass(in b2Polygon shape, float density);

  /// <summary>
  /// Compute the bounding box of a transformed circle
  /// </summary>
  /// <returns>Original C type: b2AABB</returns>
  /// <param name="shape">(Original C type: const b2Circle*)</param>
  /// <param name="transform">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputeCircleAABB(in b2Circle shape, b2Transform transform);

  /// <summary>
  /// Compute the bounding box of a transformed capsule
  /// </summary>
  /// <returns>Original C type: b2AABB</returns>
  /// <param name="shape">(Original C type: const b2Capsule*)</param>
  /// <param name="transform">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputeCapsuleAABB(in b2Capsule shape, b2Transform transform);

  /// <summary>
  /// Compute the bounding box of a transformed polygon
  /// </summary>
  /// <returns>Original C type: b2AABB</returns>
  /// <param name="shape">(Original C type: const b2Polygon*)</param>
  /// <param name="transform">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputePolygonAABB(in b2Polygon shape, b2Transform transform);

  /// <summary>
  /// Compute the bounding box of a transformed line segment
  /// </summary>
  /// <returns>Original C type: b2AABB</returns>
  /// <param name="shape">(Original C type: const b2Segment*)</param>
  /// <param name="transform">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2AABB b2ComputeSegmentAABB(in b2Segment shape, b2Transform transform);

  /// <summary>
  /// Test a point for overlap with a circle in local space
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shape">(Original C type: const b2Circle*)</param>
  /// <param name="point">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PointInCircle(in b2Circle shape, Vector2 point);

  /// <summary>
  /// Test a point for overlap with a capsule in local space
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shape">(Original C type: const b2Capsule*)</param>
  /// <param name="point">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PointInCapsule(in b2Capsule shape, Vector2 point);

  /// <summary>
  /// Test a point for overlap with a convex polygon in local space
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="shape">(Original C type: const b2Polygon*)</param>
  /// <param name="point">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2PointInPolygon(in b2Polygon shape, Vector2 point);

  /// <summary>
  /// Ray cast versus circle shape in local space.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Circle*)</param>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastCircle(in b2Circle shape, in b2RayCastInput input);

  /// <summary>
  /// Ray cast versus capsule shape in local space.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Capsule*)</param>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastCapsule(in b2Capsule shape, in b2RayCastInput input);

  /// <summary>
  /// Ray cast versus segment shape in local space. Optionally treat the segment as one-sided with hits from
  /// the left side being treated as a miss.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Segment*)</param>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
  /// <param name="oneSided">(Original C type: bool)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastSegment(in b2Segment shape, in b2RayCastInput input, [MarshalAs(UnmanagedType.U1)] bool oneSided);

  /// <summary>
  /// Ray cast versus polygon shape in local space.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Polygon*)</param>
  /// <param name="input">(Original C type: const b2RayCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2RayCastPolygon(in b2Polygon shape, in b2RayCastInput input);

  /// <summary>
  /// Shape cast versus a circle.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Circle*)</param>
  /// <param name="input">(Original C type: const b2ShapeCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastCircle(in b2Circle shape, in b2ShapeCastInput input);

  /// <summary>
  /// Shape cast versus a capsule.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Capsule*)</param>
  /// <param name="input">(Original C type: const b2ShapeCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastCapsule(in b2Capsule shape, in b2ShapeCastInput input);

  /// <summary>
  /// Shape cast versus a line segment.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Segment*)</param>
  /// <param name="input">(Original C type: const b2ShapeCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastSegment(in b2Segment shape, in b2ShapeCastInput input);

  /// <summary>
  /// Shape cast versus a convex polygon.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="shape">(Original C type: const b2Polygon*)</param>
  /// <param name="input">(Original C type: const b2ShapeCastInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCastPolygon(in b2Polygon shape, in b2ShapeCastInput input);

  /// <summary>
  /// Compute the convex hull of a set of points. Returns an empty hull if it fails.
  /// Some failure cases:
  /// - all points very close together
  /// - all points on a line
  /// - less than 3 points
  /// - more than B2_MAX_POLYGON_VERTICES points
  /// This welds close points and removes collinear points.
  /// @warning Do not modify a hull once it has been computed
  /// </summary>
  /// <returns>Original C type: b2Hull</returns>
  /// <param name="points">(Original C type: const b2Vec2*)</param>
  /// <param name="count">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Hull b2ComputeHull(Vector2[] points, int count);

  /// <summary>
  /// This determines if a hull is valid. Checks for:
  /// - convexity
  /// - collinear points
  /// This is expensive and should not be called at runtime.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="hull">(Original C type: const b2Hull*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2ValidateHull(in b2Hull hull);

  /// <summary>
  /// Compute the distance between two line segments, clamping at the end points if needed.
  /// </summary>
  /// <returns>Original C type: b2SegmentDistanceResult</returns>
  /// <param name="p1">(Original C type: b2Vec2)</param>
  /// <param name="q1">(Original C type: b2Vec2)</param>
  /// <param name="p2">(Original C type: b2Vec2)</param>
  /// <param name="q2">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2SegmentDistanceResult b2SegmentDistance(Vector2 p1, Vector2 q1, Vector2 p2, Vector2 q2);

  /// <summary>
  /// Compute the closest points between two shapes represented as point clouds.
  /// b2SimplexCache cache is input/output. On the first call set b2SimplexCache.count to zero.
  /// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.
  /// </summary>
  /// <returns>Original C type: b2DistanceOutput</returns>
  /// <param name="input">(Original C type: const b2DistanceInput*)</param>
  /// <param name="cache">(Original C type: b2SimplexCache*)</param>
  /// <param name="simplexes">(Original C type: b2Simplex*)</param>
  /// <param name="simplexCapacity">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2DistanceOutput b2ShapeDistance(in b2DistanceInput input, ref b2SimplexCache cache, b2Simplex[] simplexes, int simplexCapacity);

  /// <summary>
  /// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.
  /// Initially touching shapes are treated as a miss.
  /// </summary>
  /// <returns>Original C type: b2CastOutput</returns>
  /// <param name="input">(Original C type: const b2ShapeCastPairInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CastOutput b2ShapeCast(in b2ShapeCastPairInput input);

  /// <summary>
  /// Make a proxy for use in overlap, shape cast, and related functions. This is a deep copy of the points.
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  /// <param name="points">(Original C type: const b2Vec2*)</param>
  /// <param name="count">(Original C type: int)</param>
  /// <param name="radius">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeProxy b2MakeProxy(Vector2[] points, int count, float radius);

  /// <summary>
  /// Make a proxy with a transform. This is a deep copy of the points.
  /// </summary>
  /// <returns>Original C type: b2ShapeProxy</returns>
  /// <param name="points">(Original C type: const b2Vec2*)</param>
  /// <param name="count">(Original C type: int)</param>
  /// <param name="radius">(Original C type: float)</param>
  /// <param name="position">(Original C type: b2Vec2)</param>
  /// <param name="rotation">(Original C type: b2Rot)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeProxy b2MakeOffsetProxy(Vector2[] points, int count, float radius, Vector2 position, b2Rot rotation);

  /// <summary>
  /// Evaluate the transform sweep at a specific time.
  /// </summary>
  /// <returns>Original C type: b2Transform</returns>
  /// <param name="sweep">(Original C type: const b2Sweep*)</param>
  /// <param name="time">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Transform b2GetSweepTransform(in b2Sweep sweep, float time);

  /// <summary>
  /// Compute the upper bound on time before two shapes penetrate. Time is represented as
  /// a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
  /// non-tunneling collisions. If you change the time interval, you should call this function
  /// again.
  /// </summary>
  /// <returns>Original C type: b2TOIOutput</returns>
  /// <param name="input">(Original C type: const b2TOIInput*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2TOIOutput b2TimeOfImpact(in b2TOIInput input);

  /// <summary>
  /// Compute the contact manifold between two circles
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="circleA">(Original C type: const b2Circle*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="circleB">(Original C type: const b2Circle*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideCircles(in b2Circle circleA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a capsule and circle
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="capsuleA">(Original C type: const b2Capsule*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="circleB">(Original C type: const b2Circle*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideCapsuleAndCircle(in b2Capsule capsuleA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between an segment and a circle
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="segmentA">(Original C type: const b2Segment*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="circleB">(Original C type: const b2Circle*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideSegmentAndCircle(in b2Segment segmentA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a polygon and a circle
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="polygonA">(Original C type: const b2Polygon*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="circleB">(Original C type: const b2Circle*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollidePolygonAndCircle(in b2Polygon polygonA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a capsule and circle
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="capsuleA">(Original C type: const b2Capsule*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="capsuleB">(Original C type: const b2Capsule*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideCapsules(in b2Capsule capsuleA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between an segment and a capsule
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="segmentA">(Original C type: const b2Segment*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="capsuleB">(Original C type: const b2Capsule*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideSegmentAndCapsule(in b2Segment segmentA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a polygon and capsule
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="polygonA">(Original C type: const b2Polygon*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="capsuleB">(Original C type: const b2Capsule*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollidePolygonAndCapsule(in b2Polygon polygonA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between two polygons
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="polygonA">(Original C type: const b2Polygon*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="polygonB">(Original C type: const b2Polygon*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollidePolygons(in b2Polygon polygonA, b2Transform xfA, in b2Polygon polygonB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between an segment and a polygon
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="segmentA">(Original C type: const b2Segment*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="polygonB">(Original C type: const b2Polygon*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideSegmentAndPolygon(in b2Segment segmentA, b2Transform xfA, in b2Polygon polygonB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a chain segment and a circle
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="segmentA">(Original C type: const b2ChainSegment*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="circleB">(Original C type: const b2Circle*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideChainSegmentAndCircle(in b2ChainSegment segmentA, b2Transform xfA, in b2Circle circleB, b2Transform xfB);

  /// <summary>
  /// Compute the contact manifold between a chain segment and a capsule
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="segmentA">(Original C type: const b2ChainSegment*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="capsuleB">(Original C type: const b2Capsule*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
  /// <param name="cache">(Original C type: b2SimplexCache*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideChainSegmentAndCapsule(in b2ChainSegment segmentA, b2Transform xfA, in b2Capsule capsuleB, b2Transform xfB, ref b2SimplexCache cache);

  /// <summary>
  /// Compute the contact manifold between a chain segment and a rounded polygon
  /// </summary>
  /// <returns>Original C type: b2Manifold</returns>
  /// <param name="segmentA">(Original C type: const b2ChainSegment*)</param>
  /// <param name="xfA">(Original C type: b2Transform)</param>
  /// <param name="polygonB">(Original C type: const b2Polygon*)</param>
  /// <param name="xfB">(Original C type: b2Transform)</param>
  /// <param name="cache">(Original C type: b2SimplexCache*)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Manifold b2CollideChainSegmentAndPolygon(in b2ChainSegment segmentA, b2Transform xfA, in b2Polygon polygonB, b2Transform xfB, ref b2SimplexCache cache);

  /// <summary>
  /// Solves the position of a mover that satisfies the given collision planes.
  /// </summary>
  /// <returns>Original C type: b2PlaneSolverResult</returns>
  /// <param name="targetDelta">the desired movement from the position used to generate the collision planes
  /// (Original C type: b2Vec2)</param>
  /// <param name="planes">the collision planes
  /// (Original C type: b2CollisionPlane*)</param>
  /// <param name="count">the number of collision planes
  /// (Original C type: int)</param>
  /// <param name="targetDelta">the desired movement from the position used to generate the collision planes
  /// (Original C type: b2Vec2)</param>
  /// <param name="planes">the collision planes
  /// (Original C type: b2CollisionPlane*)</param>
  /// <param name="count">the number of collision planes
  /// (Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2PlaneSolverResult b2SolvePlanes(Vector2 targetDelta, b2CollisionPlane[] planes, int count);

  /// <summary>
  /// Clips the velocity against the given collision planes. Planes with zero push or clipVelocity
  /// set to false are skipped.
  /// </summary>
  /// <returns>Original C type: b2Vec2</returns>
  /// <param name="vector">(Original C type: b2Vec2)</param>
  /// <param name="planes">(Original C type: const b2CollisionPlane*)</param>
  /// <param name="count">(Original C type: int)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern Vector2 b2ClipVector(Vector2 vector, b2CollisionPlane[] planes, int count);

  /// <summary>
  /// Is this a valid number? Not NaN or infinity.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="a">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidFloat(float a);

  /// <summary>
  /// Is this a valid vector? Not NaN or infinity.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="v">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidVec2(Vector2 v);

  /// <summary>
  /// Is this a valid rotation? Not NaN or infinity. Is normalized.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="q">(Original C type: b2Rot)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidRotation(b2Rot q);

  /// <summary>
  /// Is this a valid transform? Not NaN or infinity. Rotation is normalized.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="t">(Original C type: b2Transform)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidTransform(b2Transform t);

  /// <summary>
  /// Is this a valid bounding box? Not Nan or infinity. Upper bound greater than or equal to lower bound.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="aabb">(Original C type: b2AABB)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidAABB(b2AABB aabb);

  /// <summary>
  /// Is this a valid plane? Normal is a unit vector. Not Nan or infinity.
  /// </summary>
  /// <returns>Original C type: bool</returns>
  /// <param name="a">(Original C type: b2Plane)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern bool b2IsValidPlane(b2Plane a);

  /// <summary>
  /// Compute an approximate arctangent in the range [-pi, pi]
  /// This is hand coded for cross-platform determinism. The atan2f
  /// function in the standard library is not cross-platform deterministic.
  /// Accurate to around 0.0023 degrees
  /// </summary>
  /// <returns>Original C type: float</returns>
  /// <param name="y">(Original C type: float)</param>
  /// <param name="x">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2Atan2(float y, float x);

  /// <summary>
  /// Compute the cosine and sine of an angle in radians. Implemented
  /// for cross-platform determinism.
  /// </summary>
  /// <returns>Original C type: b2CosSin</returns>
  /// <param name="radians">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2CosSin b2ComputeCosSin(float radians);

  /// <summary>
  /// Compute the rotation between two unit vectors
  /// </summary>
  /// <returns>Original C type: b2Rot</returns>
  /// <param name="v1">(Original C type: b2Vec2)</param>
  /// <param name="v2">(Original C type: b2Vec2)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Rot b2ComputeRotationBetweenUnitVectors(Vector2 v1, Vector2 v2);

  /// <summary>
  /// Box2D bases all length units on meters, but you may need different units for your game.
  /// You can set this value to use different units. This should be done at application startup
  /// and only modified once. Default value is 1.
  /// For example, if your game uses pixels for units you can use pixels for all length values
  /// sent to Box2D. There should be no extra cost. However, Box2D has some internal tolerances
  /// and thresholds that have been tuned for meters. By calling this function, Box2D is able
  /// to adjust those tolerances and thresholds to improve accuracy.
  /// A good rule of thumb is to pass the height of your player character to this function. So
  /// if your player character is 32 pixels high, then pass 32 to this function. Then you may
  /// confidently use pixels for all the length values sent to Box2D. All length values returned
  /// from Box2D will also be pixels because Box2D does not do any scaling internally.
  /// However, you are now on the hook for coming up with good values for gravity, density, and
  /// forces.
  /// @warning This must be modified before any calls to Box2D
  /// </summary>
  /// <returns>Original C type: void</returns>
  /// <param name="lengthUnits">(Original C type: float)</param>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern void b2SetLengthUnitsPerMeter(float lengthUnits);

  /// <summary>
  /// Get the current length units per meter.
  /// </summary>
  /// <returns>Original C type: float</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern float b2GetLengthUnitsPerMeter();

  /// <summary>
  /// Use this to initialize your world definition
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: b2WorldDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WorldDef b2DefaultWorldDef();

  /// <summary>
  /// Use this to initialize your body definition
  /// @ingroup body
  /// </summary>
  /// <returns>Original C type: b2BodyDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2BodyDef b2DefaultBodyDef();

  /// <summary>
  /// Use this to initialize your filter
  /// @ingroup shape
  /// </summary>
  /// <returns>Original C type: b2Filter</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2Filter b2DefaultFilter();

  /// <summary>
  /// Use this to initialize your query filter
  /// @ingroup shape
  /// </summary>
  /// <returns>Original C type: b2QueryFilter</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2QueryFilter b2DefaultQueryFilter();

  /// <summary>
  /// Use this to initialize your surface material
  /// @ingroup shape
  /// </summary>
  /// <returns>Original C type: b2SurfaceMaterial</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2SurfaceMaterial b2DefaultSurfaceMaterial();

  /// <summary>
  /// Use this to initialize your shape definition
  /// @ingroup shape
  /// </summary>
  /// <returns>Original C type: b2ShapeDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ShapeDef b2DefaultShapeDef();

  /// <summary>
  /// Use this to initialize your chain definition
  /// @ingroup shape
  /// </summary>
  /// <returns>Original C type: b2ChainDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ChainDef b2DefaultChainDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup distance_joint
  /// </summary>
  /// <returns>Original C type: b2DistanceJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2DistanceJointDef b2DefaultDistanceJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup motor_joint
  /// </summary>
  /// <returns>Original C type: b2MotorJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MotorJointDef b2DefaultMotorJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup mouse_joint
  /// </summary>
  /// <returns>Original C type: b2MouseJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2MouseJointDef b2DefaultMouseJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup filter_joint
  /// </summary>
  /// <returns>Original C type: b2FilterJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2FilterJointDef b2DefaultFilterJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroupd prismatic_joint
  /// </summary>
  /// <returns>Original C type: b2PrismaticJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2PrismaticJointDef b2DefaultPrismaticJointDef();

  /// <summary>
  /// Use this to initialize your joint definition.
  /// @ingroup revolute_joint
  /// </summary>
  /// <returns>Original C type: b2RevoluteJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2RevoluteJointDef b2DefaultRevoluteJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup weld_joint
  /// </summary>
  /// <returns>Original C type: b2WeldJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WeldJointDef b2DefaultWeldJointDef();

  /// <summary>
  /// Use this to initialize your joint definition
  /// @ingroup wheel_joint
  /// </summary>
  /// <returns>Original C type: b2WheelJointDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2WheelJointDef b2DefaultWheelJointDef();

  /// <summary>
  /// Use this to initialize your explosion definition
  /// @ingroup world
  /// </summary>
  /// <returns>Original C type: b2ExplosionDef</returns>
[DllImport(Box2DLibrary, CallingConvention = CallingConvention.Cdecl)]
public static extern b2ExplosionDef b2DefaultExplosionDef();

    }
}
